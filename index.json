[{
    "title": "[心得]米米的確診漂流記",
    "date": "",
    "description": "我的保險金到底什麼時候才下來＝＝",
    "body": "前言 大家好，我要來久違的更新文章了，最近剛服完兵役，正在學習Vue.js，之後會寫一些文章。這次就來分享我的確診日記。\n 目錄：\n 米米的確診漂流日記 你有保保險嗎？ 確診了該怎麼辦？   米米的確診漂流日記 事發時間為 2022 / 06 / 05 ，下午五點，當時的我要提早收假回營區，因此打電話給值星說要請他們拿快篩試劑到哨口（那時只要進入營區就要快篩，19:00 - 21:00 會有人在哨口等著收假人員，但我提早回營因此要請人拿快篩試劑到哨口）\n值星就問我為什麼要提早回營，我就提到身體有一點小不舒服想要回營休息，他懷疑我確診了，於是通報上級長官。過沒多久副中隊長（之後簡稱「副中」）就打電話給我。\n 副中：你不舒服為什麼不提早講？要等到收假前幾小時才說？\n我：我中午有測過快篩，結果為陰性，我猜是前幾天放假太晚睡，所以不舒服，應該不是確診。\n副中：我不管，雖然是陰性但有可能由陰轉陽，我先開你一天事假，你明天如果還是陰性，我再放你進營區。\n 副中還希望我要先回家，隔天再收假，但我家在台北誒！坐高鐵來回就要 1400 元了，這樣划不來，我不如去住飯店還比較便宜。\n時間來到晚上六點，我在前往飯店的路上經過便利商店就買隻快篩，想說若不幸確診了會對飯店造成麻煩。不測還好，一測直接兩條線！我急忙跑到空曠的場所想說該怎麼辦，上網了查資料，便打電話給1999通報，希望他們能提供防疫旅館。\n這通電話撥了1小時才才撥進去，事情交代完畢，他們說後續會有衛生局人員聯絡我，於是我又等了1小時才接到電話。\n 我：我想安排防疫旅館，我快篩陽性。\n衛生局：您只有快篩陽性，並未由醫療機構通報確診，無法安排防疫旅館，需要請您線上看診，通報確診才行。\n我：真的不行先通融一下嗎？我是台北人在台中服役，現在軍營不讓我進去，我也不可能去住飯店，總不可能流落街頭吧！\n衛生局：我知道先生的難處，但我們也有很多案例像先生一樣，但都是請他們先去線上看診，再預約防疫旅館。\n 晚間十點，我拖著疲憊的身軀勉強走到鄰近醫院希望至少有個病床能讓我度過一晚，但那裡的急診只提供重症病人病床，其餘疑似確診的病人只有提供PCR、藥物而已。PCR採檢完呈現陽性，我心想這次終於能排防疫旅館了吧，再次致電聯絡1999，一樣轉接衛生局，結果他們跟我說已經超過通報時間，最快也是明天早上十點的事。\n我非常無語，你們說沒有通報確診現在我做完PCR並且也確診了，你跟我說要等到明天早上？我人生地不熟，晚上十一點沒有地方可以去，我真的要流落街頭嗎？我不死心，改致電給1922，他們又是一樣轉接到衛生局，一樣沒辦法，後續成功嶺替代役訓練班的醫療助理、隊長、副中接連打電話來詢問情況，我也只好再把事情經過講給他們聽。所以全替代役成功嶺訓練班都知道有個役男在外面確診流落街頭（嗚嗚。\n最後結局是，我家人南下開車載我回家，到家時間是凌晨四點，我也懶得洗澡直接倒頭就睡，確診，真的很不舒服。\n隔天我打電話給台北的1999說要住防疫旅館，下午他們幫我安排了集中檢疫所，而且是「公費」！我就開始了7天隔離生活。\n你有保保險嗎？ 我有買一張和泰的保單（補償B），確診5萬隔離4萬，我朋友有的買5、6張，確診可以拿大概30萬吧，把他當投資==\n這是我的保單：\n   保障項目 理賠金額     住院日額保險金 1,000 / 日（最高給付60日）   負壓隔離或加護病房醫療保養金 1,000 / 日（最高給付60日）   補償保險金 50,000   隔離費用補償保險金 40,000    沒有買到防疫保單的人也別氣餒，如果有入住防疫旅館或是集中檢疫所，只要醫療險裡有理賠住院日額皆可申請。\n 配合中央疫情指揮中心於111年4月8日公布「COVID-19確診個案居家照護管理指引」，金管會協調產、壽險公會就現行已售防疫保險商品承保範圍包含住院日額保險金部分，對於無症狀或輕症確診者於居家照護期間，得比照一般住院情形予以理賠。\n 確診了該怎麼辦？ 之前我是沒經驗，若再從頭一次我絕對不會讓自己流落街頭，至少先找個飯店住一晚再說，這其實並不犯法，我也跟衛生局的人確認過了，只要尚未通報確診，基本上到處趴趴走都沒事（不過還是不要這樣拉～\n這裡舉最簡單的例子，若是在家快篩陽性，首先先想辦法讓醫療機構通報確診，看要線上看診、社區快篩站之類的。\n  修訂「嚴重特殊傳染性肺炎」之病例定義  之後，便可以在健保快易通上查詢測驗結果。\n  測驗紀錄  個案自主回到系統 確診大約第一天，就會收到簡訊，請你填寫個案自主回報系統。值得注意的是有沒有密處接觸者的問題，這攸關對方需不需要隔離以及有沒有保險金可拿：選擇0+7可以不用在家隔離，只需要自助管理，確認是陰性就好，沒有隔離保險金可拿，因為缺乏隔離事實；選擇3+4要在家隔離三天，剩下四天自主管理，一樣是陰性就好，這就有保險金可拿。\n  個案自主回報簡訊   傳染病防治法第48條：\n 主管機關對於曾與傳染病病人接觸或疑似被傳染者，得予以留驗；必要時，並得令遷入指定之處所檢查、施行預防接種、投藥、指定特定區域實施管制或隔離等必要之處置。 中央主管機關得就傳染病之危險群及特定對象實施防疫措施；其實施對象、範圍及其他應遵行事項之辦法，由中央主管機關定之。  保單條款是依照法定傳染病48條約定，關鍵就是同住親友與確診者接觸，原則上是「3+4」（3天居家隔離、4天自主管理），例外才是「0+7」，換言之，依保單條款，符合48條規定，就是需要理賠。\n 防疫門診及領藥 既然確診了，就不能到處趴趴走，看診自然也不行。那該如何看診呢？一樣是使用線上看診預約～拿藥就請親朋好友或是家人去幫忙拿。\n若是想要使用COVID-19口服抗病毒藥物，可參考以下幾間醫院：\n 結語 有關任何最新疫情最新消息、處理流程等都以衛生福利部疾病管制署為主，各位可以將此連結加入我的最愛，裡面有詳細的流程可參考。\n希望疫情能夠早點過去，醫護人員也辛苦了。\n",
    "ref": "/blog/20220729_got_covid/"
  },{
    "title": "[心得]替代役訓練班-班本部",
    "date": "",
    "description": "成功嶺替代役訓練班您好，我是勤務役男ＸＸＸ，很高興為您服務～",
    "body": "前言 上一篇有提及到替代役新訓的心得與攻略，沒有看過的請查看【替代役攻略】225T成功嶺新訓14天心得＆部分攻略\n網路上提到成功嶺新訓的文章有非常多，留在成功嶺一般中隊的文章也還是有幾篇，但有關「班本部」的文章幾乎是沒有的，於是我這不就來了嘛ww～\n這篇文章會以「我的視角」來介紹班本部，其中的內容可能因中隊級幹部、處室長官而有所改變，實際的內容請等你到班本部才會知道，那就開始吧。\n 目錄：\n 什麼是班本部？ 選班本部的原因 生活作息 工作內容 澄清事項 結語   什麼是班本部？ 替代役的主管機關為「內政部役政署」，旗下有五大組，分別是徵集組、甄選組、管理組、權益組以及訓練組。而「訓練組」就是替代役訓練班，替代役訓練班底下分成四大科：\n 行政科  資訊 / 工程：幫你裝MDM、資訊相關的都問他們。 傳令：收發公文、接待貴賓，長官是執秘（替代役沒人比他大）。 行裝：裝備業務、洗衣業務。 人事：管理進出營區打卡記錄、榮譽假系統（處理你的所有假，請跟人事打好關係）。   教務科  課務 / 教材：排課（含新訓、幹訓、區訓、在職訓）、EMT1、核銷、架器材。 文康 / 播音：比賽相關、藝文競賽、鑑測、成績統計、音控。 諮商中心 / 圖書中心 ：諮商、管理圖書館。   管考科  預算：開結訓典禮、勤務專訓。 管理：訪視、每日動態。 考核：管理簽呈、綜合考評、罰勤。 攝影：攝影、役男大頭照、製作文宣海報。 研替：研替相關問題請找這裡，課務只負責一般替代役相關業務。   補給科  食勤：聯繫卡多、食物有問題就找他們。 財產 / 車輛：財產清算、當司機（接送長官、開柴車運送垃圾）。 機電：處理機電相關事務、聯繫廠商。 水電：處理水電相關事務、聯繫廠商。 物品庫房：發放物品（辦公用品）。 服裝庫房：發放服裝（制服、操作服）。 醫療：聯繫救護車、快篩、調查疫苗施打人數、發放醫療物品。    除了四大科外，還有各個大隊，而班本部就屬於直屬大隊裡的「勤務二中隊」。\n  替代役訓練班組織圖  班本部主要分布在四大科的處室裡，你可以想像就是坐在辦公室當個公務人員，跑簽呈、送公文。\n但\u0026hellip;\u0026hellip;只要你在營區中就要有中隊管你（要不在成功嶺就不有諸多限制），照理來說，班本部在上班時間是受到處室文職長官所管理的；下班時間後就是一般中隊，時間到了該打掃還是要打掃，該點名還是要點名，因此如果你遇到一位「不太愛管事」的中隊長，那恭喜你，你在班本部會過得很爽～\n選班本部的原因 我要特別再次說明，以下的言論皆是我本人親身經歷，或是有朋友在其他地方，紀錄他的心得，並不代表真正的實際狀況。\n能夠自由排假且有比較多榮譽假 只要你留在成功嶺，不論是哪個單位，皆能自由排假。相比於分發到其他單位的人只能放週休二日；我們最多一次可以連續放五天的假，一樣是見紅就會有假，像是清明連假我們可以選擇留守，再將這些假排到其他天，這對於家裡住得比較遠的役男，可以減少交通費，而且享受多一些「正常人的生活」。\n正常來講外面的單位開給役男太多榮譽假（雖然有些真的給的很大方，我朋友一次就被開四天榮譽假，重點是他什麼貢獻都沒有，就有假可以放，真的讓我羨慕嫉妒恨）\n而選擇成功嶺，接訓的話會有接訓榮，還會有個中隊的環境競賽或是藝文競賽等等，有些假還都是一天起跳，這些都是外面單位所沒有的。至於假的多寡就請大家進來班本部了解了解：）\n拓展人脈 班本部裡有非常多的處室，每個處室裡都會需要用到役男，因此班本部的役男人數會較多，在這裡可以認識到很多人～更何況有些處室跟一般中隊役男有接觸，又或者是參加幹訓班會認識到一群共患難的兄弟們。這也是我想進成功嶺，進班本部的原因。\n對我來說，在社會中交朋友是非常困難的，彼此忙於工作，或多或少牽扯利益，又或者是忙於家庭等種種因素，在社會中認識的朋友都是處於見面三分情；而在成功嶺，大家年紀相仿，有共同話題，下班之後可以揪個運動，或者是一起外散吃飯，像我們處室就會定期跟文職長官吃飯喝酒，長官每次都會把我們灌酒灌到不要不要的，此時就會有人出來擋酒，你一杯我一杯，這種氛圍我真的很喜歡～\n生活作息    時間 內容     0600 起床   0625-0630 早點名   0635-0700 早掃   0800 各處室辦公   1130 用餐   1330 各處室辦公   1700 用餐   2100 晚點名   2200 就寢    這是大致的方向，但有時候會根據實際狀況有所調動，像是在梯間時各處室的業務量相對較少，我們就會分配到上下午的機動打掃等等。\n工作內容 班本部主要的工作是協助處室長官完成業務，表面上看起來很爽，但實際上工作量是真的蠻多的。\n許多處室都會面臨人力吃緊的問題，如果處室中有幹部，那麼在他背值星那段時間基本上是要排除他的。此外我們還需要輪打飯收飯、衛哨等等跟一般中隊一樣的公務。\n我是課務組的，工作內容是負責講師鐘點費核銷，簡單來講就是負責管發錢的。我需要先製作印領清冊給講師簽名（此時課表如果一直調動，那麼我就要重新調整印領），等到所有課程結束後我才能將之做成一份公文。而一般新訓不是只要做一份而已，他還分一般梯、研替、家因、成長營等等，工作量真的蠻多的。\n澄清事項 在我新訓期間，隊上建議我不要去班本部，就會開始說班本部的壞話，後來留在班本部才漸漸知道班本部為什麼會被一般中隊討厭，以下我整理出了幾點：\n長官常到各中隊抄家，各中隊被抄家的不滿直接轉嫁到班本部人員身上？ 長官想要跑去哪我們管不了，但某助理就非～常～喜歡去突擊檢查其他中隊，被他抓到就馬上開簽。我們其實也跟助理聊過，他會以「抄家」這兩字形容他的行為，但本來就不需要如此，講抄家擺明了就是要去陷害對方、弄死對方，但他也沒有要改的意思，我們也是不樂見此事的發生，因為助理也會抄家班本部＝＝\n班本部有權扣一般中隊評分，害一般中隊被拔接訓榮？ 以課務為例，在上課前幾天我們會交代總隊（各中隊輪流擔任，統一發布或交代事項給其他中隊）各種注意事項，如新訓役男在上課前十分鐘就要到、需要更換上課海報等等。到了上課當天我們去現場查看發現有人遲到或是設備沒有安裝好，而且我們居然找不到負責人，因此只能扣分。\n被扣分的中隊當然會不爽，但班本部確實有告知總隊哪些地方需要特別注意，而「總隊沒有把收到的消息繼續往下傳遞」就是這次的缺失，也就是所謂的「資訊不對稱」。我們也不想害一般中隊被扣榮譽假，但上有長官施加壓力，我們不得不做出處分。\n班本部都是爽缺，工作很輕鬆？ 我個人不喜歡帶隊，不喜歡對著新訓役男破口大罵，不喜歡頂著太陽帶隊操課，對我而言班本部是個好去處，但他也沒有想像中這麼爽。\n其他處室的情況我不清楚，不過就課務組而言我們真的非常忙碌。接訓期間只要有要上課，那就都是課務的管轄範圍，包含大餐課、專題演講等等，我們都在忙碌；新訓役男會考到的EMT1證照也是我們處室負責，負責EMT的同仁忙到凌晨一兩點都是常見的。\n此外還有人情世故的壓力存在，我們上有長官，下有一般中隊。長官今日要執行新的政策或是有新的規則，我們就需要傳達給一般中隊，一般中隊可能對於新的法令有所排斥，便會找傳話的人麻煩（反應做不到或是提出異議，又或者說是班本部跑去長官耳邊嚼舌根），但我們也只是執行長官命令，沒有權力干涉，因此班本部又會被記上一點仇恨。\n 能不懲處我們當然不會懲處，但到了要懲處的時候也請體諒我們上有長官，大家都是出來服役的，不需要相互為難，希望大家都能順順利利的服完兵役！\n 結語 本篇主要是想要介紹班本部到底是在做什麼的，內容可能有些模糊（畢竟我還在裡面，不能把話講太死太清楚），希望還是多多少少有幫助到各位學弟，有任何問題可以先問問你們隊上的幹部（不過他們可能會說班本部不好之類的）或是私訊我，能回答的我會盡量回答，不能回答的就要靠各位的小腦袋想想ㄌ。\n這裡就給個提示，有人有想過為什麼「你很難查到有關替代役班本部的文章嗎？」新訓會有一堆人寫這不意外，消防、社家署、退輔會的也大有人在，但唯獨班本部的文章可是少之又少，這點大家可以好好的想想～\n以上就是班本的介紹，希望能給學弟們一些參考方向。\n",
    "ref": "/blog/20220423_substitute_military_2/"
  },{
    "title": "[心得]替代役230T攻略＆心得",
    "date": "",
    "description": "替代役青年們夢想起飛～",
    "body": "前言 一月底剛結束230梯的新訓，接著我就去過年了，下單位後我認真處理單位的事情（？ 於是又過了一個月，等到231梯的學弟們快要新訓，才想說太久沒更新網站，該寫些心得了，於是才有這篇～\n這裡先講好，以下是我在新訓的體驗，大家進去可能會跟我不一樣。但萬變不離其宗，事前準備的好，你才能爽爽過，因此本篇絕對有參考價值ㄉ\n 目錄：\n 事前準備 名詞解釋 生活小撇步 心得   事前準備 由於很趕，再加上年代久遠（？，所以我貼上我朋友寫的文章先來擋一下，這應該不爲過吧，哈哈哈～\n【替代役攻略】225T成功嶺新訓14天心得＆部分攻略\n我會根據上面的文章做補充：\n 衛生紙 / 袖珍包：備妥一包抽取式衛生紙當作內務檢查用，請不要打開。袖珍包多帶一些會很好用，我都是把它放在外套口袋或是褲子口袋裡。 喉糖：越多越好，多多益善。喉糖是唯一能帶在身上吃的，也是裡面的貨幣，它可以拿來交朋友，也可以拿來玩五子棋（笑～ 行動電源、耳機：在裡面沒有插座可以讓你充電，需要自備。耳機要用有線的，藍芽耳機是違禁品。 鞋跟墊片：公發鞋子會缺號！鞋子穿起來會太大，而且皮鞋會磨腳跟，所以建議帶（我覺得其他人應該沒說過這個哈哈哈 雙面膠：黏名牌很好用，整理內務也好用。 乳液 / 護手霜：打飯過水要洗很多碗，手會裂開。 耳塞：有些人躺到床上就開始演奏交響樂，忽大忽小，節奏超亂，會讓你睡不著。 手電筒原子筆：違禁品，但相信我，你會需要用到它！帶手電筒原子筆的話你可以藏在文具袋裡面。  行有餘力的話可以先練練以下幾點，先學好總比之後在裡面被電還要好：\n  速度類：練習大號速度（可能只有蹲廁）、吃飯速度（因為還要洗碗）、洗澡速度（後面還有人要洗）。在裡面動作越快越好。\n  學摺棉被、折蚊帳：有些中隊教的折法可能是錯的，我在網路上找到這兩個影片，供大家參考～\n     看階級：主要記住兩個，兩勾、一槓。兩勾「 \u0026laquo; 」就是分隊長，也就是常常帶你們的人；一槓「 | 」就是區隊長。這兩種人都是留成功嶺然後去報幹的。另外幾種是官校出來的軍官，看看就好。兩槓「 || 」是副中隊長；三槓「 ||| 」是中隊長；一顆梅花是副大隊長；兩顆梅花是大隊長。    幹部職稱    數字別稱：1么、2兩、3三、4四、5五、6六、7拐、8八、9勾、0洞。\n  練體能：3000公尺、伏地挺身、仰臥起座能練練就多練練ㄅ～\n  考古題：考古題連結，需要的自行印下來。\n   名詞解釋 我列一些名詞解釋，讓大家了解阿替們的簡語吧！\n  黑大：黑色大型行李帶。會在新訓的前幾天發給各位裝私服、違禁品等用不到的東西，並且統一放置在倉庫裡，等到新訓結束後才會發還。\n  重櫃：放貴重物品的櫃子。你的手機、錢包、行動電源都會放在裡面，只有洗打時間才能開放使用。\n  洗打：洗澡跟打電話的時間。有的中隊洗澡跟打電話的時間是分開來計算，用意是希望大家都能洗到澡，之後再一起打電話；有些中隊適合在一起計算，浴室就不會塞車，不過有些人會用手機而不洗澡，夏天就會很臭。另外，幹部們會利用扣洗打時間要求部隊，各位就好自為之吧。\n  卡多：卡多利亞，是負責供餐的廠商。口味清淡，非常難吃，不過幾天後你就會開始期待下一餐（大家自行體會，而且你會覺得每天都在等吃飯）。另外，素食餐點其實還不錯，可以選擇吃素然後去偷幹葷食。\n  站哨：當保全，每天晚上輪流，每個小時2 - 3人不等，站哨時間為22:00 - 06:00。通常會在30分提醒下一哨的人員起來，45分交接，切記不要逾哨，後果自負。\n  電測：電腦測驗。測驗你的身心靈健康，我認為沒什麼參考性可言。如果分數太低會被上層關心，或是被拉去諮商。\n  打飯過水班：顧名思義處理食物相關的工作，工作內容為準備打飯菜的器具及清洗的工具\u0026hellip;擔任打飯過水班可以拿榮譽假（我覺得福利沒有很好）。\n  洗委、總洗委：處理所有人的換洗衣物。所有人要將三寶（內衣、內褲、襪子）放進洗衣袋統一拿去清洗，洗完味道很像爆米花味，就算你不想洗還是要交，不然會被扣分，而且還需要付200元的洗衣費==\n  體溫小老師：因應疫情，每天會有4次量體溫的時段，我認為這是最輕鬆而且加分加蠻多的公差，能搶到算你好運！\n  替歌小老師：帶領大家練習替歌，若替歌有得名會很爽，沒得名就是個吃力不討好的公差。\n  替歌：替代役之歌比賽。若有機會得名會有榮譽假，替歌比賽要看中隊有沒有給時間練習以及大家團不團結。像我們這次拿到第一名，就有4個小時的榮譽假可以放，真爽～\n     基教：基本教練。其內容有分立正、稍息、踏步、左轉、右轉及向後轉的基本訓練，此課程好好練習，這攸關你之後分發的成績。\n  大餐課：非常無聊的課程，期間你最好看考古題、看書（不能成冊，要用印的）、玩數獨、用喉糖玩五子棋（我同梯幹的，超猛）、玩自製紙牌（抓到會被罰）\u0026hellip;\u0026hellip;. 反正就是拿來打發時間用的課程，無聊是無聊但不要睡覺。\n  EMT1：初級救護技術員課程。他是我認為在這新訓期間最有意義的課程，也是最花錢的，在外面要上這門課的費用落在5000~8000，你進來替代役直接送你課程。授課老師是消防員，講課方式有都蠻有趣的，而且考試也比外面簡單，所以進替代役至少拿個EMT1的證照回家吧！\n  戰鬥阿嬷：有氧課程。從第1梯帶到230梯，是個超級猛的阿嬷，上他的課好好上，認真做操，皮繃緊就不會被噴（看別人被電會覺得很好笑拉，但儘量不要笑出來）。唸體育相關以及在亞洲大學的學生會叫上台當示範組（不要苟且，一定會被叫上去）。231梯開始「可能不會有戰鬥阿嬷的課」，我在想她差不多也該退休了（？\n  醫護所：有事沒事可以去晃晃（誤。醫護所只有家醫科，因此牙痛這種會轉診到營區外的軍醫院。只要不舒服就可以來醫護所，這樣還可以躲大餐課、打掃\u0026hellip;不過戰鬥阿嬷的課躲不掉，她會跑去醫護所抓你回來。\n  轉診：剛剛提過可以轉診到外面的軍醫院。轉診時段分上午跟下午，啊記得帶錢跟健保卡，這等同看病。若要臨時取消轉診，「記得回醫護所填放棄轉診單」。\n  鑑測：主要考3000公尺、基教、學科，這個分數再加上內務分數就是你在成功嶺的分數，這攸關役別甄選能不能選到你理想的目標。 役別甄選：選擇分發單位的日子。開缺會看條件，有些會看學歷，有些會看專業技能或者是分數等等。舉例，我們這梯消防役佔大多數，多數人就會去搶，如果搶輸別人就要等第二輪分發搶別人剩下的！所以要認清自己的實力，發現搶不過別人就趕快先跑，才不會只能撿剩的缺。\n  專訓：專業訓練。撥交後役男會跟著單位走，單位會培訓役男，這段時間就是專訓。專訓的時間由單位所定，有的三天，有的五天。另外，家因役男的專訓會留在成功嶺。\n  署長信箱：有任何不爽的事情可以寫署長信箱，填寫的時候請留正確的聯絡方式，聯絡你他們也不會解決。\n  生活小撇步 這裡一樣借用我朋友的文章，下面進行補充。\n【替代役攻略】225T成功嶺新訓14天心得＆部分攻略\n 分隊不要站排頭前三以及最後兩個：前三個可能會被叫去做事，像我們中隊就規定每個分隊第二人是洗委。不要站最後兩個是因為在基教時最後兩人要喊「謝謝鑑測官」。 做完份內的事再去幫別人：團體生活大家要互相幫忙，但請先把自己顧好，再去幫其他人。 算好時機準備洗澡：通常晚餐吃完回到隊部會有休息時間，此時可以準備好盥洗用品，之後洗打時間可以拿了臉盆就走。  心得 不要頭髮剃光就跟著也把腦子剃掉了，進去裡面請用點腦子，不要讓長官、同梯看笑話或是受苦！\n成功嶺的生存之道是「不走在最前，也不走在最後」，大家怎麼做你就跟著做。另外，看到其他人即將犯錯或忘記什麼事情要做，請「一定要提醒或嘗試幫他」，畢竟這是團體生活，有人做錯可能會讓全體扣分或者有其他懲罰。\n最後是心態問題。我想很多人會覺得這半年 / 一年的兵役很浪費時間，對我來說卻是個能夠稍微喘息、放鬆的時刻。我畢業後就直接工作，工作期間沒什麼社交活動，偶爾跟朋友吃吃飯而已。入伍後我認識了很多新朋友，也拓展了人脈，更是離開了同溫層。沒來當兵你不會知道你的鄰兵可能是前空手道國手，他可能是在台積電上班的工程師，他可能是準備開公司的老闆，他可能是已經在授課的團課老師\u0026hellip;\u0026hellip;\n 這幾天，與同袍完成比賽奪下替歌第一；這幾天，幾乎是五點不到就被吵起；這幾天，凌晨站哨搞到整天沒精神；這幾天，吃卡多無味餐還要用搶的；這幾天，整梯公幹一個人真是笑到靠北，這幾天，認識了好多人聽到了好多故事，讓我知道我要更努力：）\n 「清心寡慾的生活，更能理出事物的真實與道理」，服役期間有很多自己的時間，不妨好好與自己對話，想想之後的人生目標，想想還有哪些事情是該去學習，該去精進的，我想這半年 / 一年很快就會過去了。\n以上是我在新訓14天的體會，23007064下台一鞠躬～\n  六班殘兵翹孤輪  ",
    "ref": "/blog/20220305_substitute_military/"
  },{
    "title": "[心得]六角學院JS直播班完課心得",
    "date": "",
    "description": "學習前端工程最好的教學平台！",
    "body": "什麼是六角學院？ 六角學院是個專注在前端領域的線上課程平台，平台上除了有預錄課程外還有直播班可以報名，直播班的進行方式就像是在開線上會議一樣，老師透過Zoom直播課程內容，學員們除了在線上與老師互動學習外，平常還有每日作業以及每週作業等練習，因此直播班適合需要有人推你一把的人，透過同儕互相影響提升能力，本次我就是參加Javascript的直播班，接下來就是心得分享～\n當初為什麼報名這堂課？ 起初，我對自己身為「社會新鮮人」這個身分感到苦惱，學校內學習的東西又雜而且不是我想要的（學校教的東西篇後端，但我想要走的是前端），畢業後雖然有工作，但工作內容也僅專注在切版，離我真正想要的前端工程還差一點距離。\n後來有開始接觸補習班、Hahow等線上課程平台，但是所學到內容也都偏向前端「設計」而非前端「工程」，之後也就不了了之了。\n最終我誤打誤撞，先是在Youtube上學習六角學院提供的Git教學，後來再更進一步的了解六角學院才決定要參加這次的JS直播班。\n  課程平台  第一週~第八週的學習過程最大的收獲是？ 先跟大家說明，六角學院把學習階段比擬成遊戲的劇情，每次的課程為主線任務，學員們要完成任務（除了主線後支線等）才會得到積分，積分越高其實也沒啥作用（笑～ 但這樣能讓學員們更有熱忱的學習～\n  積分的用途（打怪用？    主線劇情進度加碼  回到正題，六角學院的課程設計是很有系統性的，每個階段的難易適中，若是從未接觸JS的人來開始學習，確實是有難度的，但是課程裡除了完善的影片可供複習，還有強大的師資陣容在線等你問問題，只要有心學習都是可以成功的。\n在這短短兩個月裡，我學習到最大的收穫是知道接下來的方向該往哪走，以及練習試著把自己的想法清楚的傳達給對方，這兩樣看似跟程式沒什麼相關，但是卻是我學習到最多的地方。\n我是本科系出生，對於程式邏輯有一定的敏感度，此外平常在上班時也要稍微修改JS程式碼，因此在直播班學到的內容對我來說算是簡單。於是我利用每週分組討論的方式跟我的小組成員每週定時線上會議，分享學習到的東西以及實作；此外從這堂課我也重新學習JS的觀念，一步一腳印的從頭開始學習，避免之後犯了基本觀念沒搞懂的錯！\n最喜歡直播班的哪些活動？ 每日任務、周末任務和主線任務，每天能夠吸收一點知識量，藉著實作重新補充。\n值得一題的事週末任務，在直播班的初期，老師出的內容是要我們寫筆記、文章，也就是大家看到的前幾篇～\n我認為寫文章是一種很好的方式來確認所學是否有完全吸收，透過文章來講解思考脈絡以及舉些簡單的例子，更能讓自己有更深刻的印象。就算哪天忘了，也可以查看自己的文章快速掌握重點！\n如果時光能倒流，會希望自己再次注意哪些細節？ 我會希望自己能夠善用助教系統（問助教問題），因為我在做任務時都沒有遇到太大的問題，有時候自己網路爬文就能解決了，沒有問到助教問題真的很可惜，希望當初能夠多善加利用這個資源，畢竟直播班貴就是貴在這裡啊！\n  助教可4很忙ㄉ，要改作業還要回覆問題～  對課程的建議或鼓勵？身為學長姐，分享些想入坑的新同學一些勉勵的話。 前端這個東西是學也學不完的，一但放棄學習就會永遠啃老本，被時代拋棄。因此有熱情、有動力是極其重要的！從0開始學習不會來不及，只要有心學習，六角的大家都會拉你一把！\n這是我在發表會製作的簡報，裡面提及了一些心路歷程以及心得分享～\n 結語 反正六角學院我是推到爆拉！有興趣了解網路上搜尋都是一大堆，我在這裡就不贅述ㄌ～\n小弟本人明天就要去當兵ㄌ，因此會有一段時間沒有更新部落格，有要聯繫我的歡迎在下方留言，我看到都會回覆：）\n",
    "ref": "/blog/20220111_hexschool_feedback/"
  },{
    "title": "[教學]圖片自適應外框大小2",
    "date": "",
    "description": "使用aspect-ratio來固定比例！",
    "body": "前言 一年前我上傳了[教學]圖片自適應外框大小的教學文章，透過控制圖片的max-width: 100%, max-height: 100%以及使用object-fit來控制，那篇的流量還蠻高的，我想一定是大家都有圖片跑版的困擾吧，因此我決定再分享我最近發現好用的方法。\naspect-ratio 這次介紹另一個語法叫做aspect-ratio，看到ratio就可以猜出它可控制比例，它的語法如下：\naspect-ratio: 1/1; // 長寬比1比1 aspect-ratio: inherit; // 繼承 aspect-ratio: initial; // 初始值 aspect-ratio: unset; // 能繼承就繼承 不能就使用初始值 其中1/1的地方是可以任意設定的，假設需要圖片以16：9的方式呈現，其值設為16/9，需要4：3的比例，就設成4/3以此類推。\n組合技：使用aspect-ratio加上object-fit 每個版面的圖片都有建議尺寸，客戶如若不按照建議尺寸亂上圖片，圖片就會大跑版，因此我們需要考量到這點，要將圖片限制在固定的區域。\n常用的方式有兩種，一種是強制將圖片等比例塞進限制的空間，不符合建議尺寸的圖片就會留有白邊：另一種是將圖片放大後裁切超出的部分，但無法控制要裁切的中心，所以不適合放有文字的圖片。\n我們先來看範例：\n object-fit可以很好的去控制圖片要contain或是cover，也就是做到前面剛剛講的兩種方式。\n以前我們我們只單純用到object-fit來控制，但它缺乏寬高，因此需要指定給它，但這樣在不同的尺寸的裝置就需要設定好幾種，非常浪費時間。\n因此我們使用aspect-ratio來控制圖片的比例，如此一來就不需要設定高度了，圖片會根據比例撐開。（本範例使用Bootstrap的欄位系統，每個欄位的寬度自然就被定下來了，因此就不需要設定寬高）。\n最後需要給定圖片的寬度，也就是width: 100%。圖片剛剛講的去設定也有可能會符合比例但是卻太小，或者是太大直接炸開，因此要去控制圖片寬度為100%讓它撐滿。\n主要的寫法整理成：\nimg{ aspect-ratio: 4/3; object-fit: contain; width: 100%; } 結語 希望這個小方法可以幫助大家，當然它還是有一定的限制在的，像是有時在display: flex裡面它就會壞掉，或是需要一定程度上的給定寬度，但總體來說我認為還是不錯的方法，供大家參考。\n",
    "ref": "/blog/20211130_aspect-ratio_object-fit/"
  },{
    "title": "[教學]何謂強制轉型、以及如何作到轉換型別？",
    "date": "",
    "description": "拜託別再自動轉型了",
    "body": "前言 相信大家在剛學習JS的時候一定會遇到 轉型（coercion） 的問題，像是：\nlet a = \u0026#34;1\u0026#34;; a = a + 2; a = a * 2; a = a + true; a = a * null; a = a / undefined; 請問每一行a的值為何呢？？\n我想很多人一定會把它拿去console.log()裡面查詢吧～\nJS會很貼心的（有夠雞婆）幫我們轉換型別，其中有分「顯性轉型（explicit coercion）」與「隱性轉型（implicit coercion）」，前者規規矩矩，你叫它轉型它才轉型；後者像一個死屁孩一樣會自動轉型，而且你還可能猜不透它會怎麼轉！！！\n本次就來了解到底轉型是怎麼一回事ㄅ～\n 目錄：\n 顯性轉型與隱性轉型 顯性轉型  轉型為布林型別：Boolean() 轉型為字串型別：toString()、String() 轉型為數值型別：Number()、parseInt()、parseFloat()   隱性轉型  轉換為布林型別：其實都是看truthy跟falsy值 轉換為字串型別：使用加號 轉換為數值型別：可以使用加號，但是小心使用     顯性轉型與隱性轉型 剛剛前面有提過強制轉型分兩種：\n 顯性轉型（explicit coercion）：透過人工的方式，以函式的方法轉換值的型別。 隱性轉型（implicit coercion）：看到兩個不同型別的值就會自動判斷，把值轉換為相同型別，再做運算。  let a = \u0026#34;1\u0026#34;; let b = \u0026#34;1\u0026#34;; console.log(Number(a) + 1); // 顯性轉型，輸出： 2（number） console.log(b + 1); // 隱性轉型，輸出： 2（number） 不管是顯性轉型或是隱性轉型，它們轉出來的型別就只會有布林值（boolean）字串（string）以及數字（number）這三種。\n顯性轉型 透過明確的JS函式方法來轉換變數的型別，對應的函式方法分別有：\n 轉換為布林型別：Boolean()。 轉換為字串型別：toString()、String()。 轉換為數值型別：Number()、parseInt()、parseFloat()。  這裡有個觀念要先澄清，變數若要轉換型別，原先的屬性下就有個類似轉換為其他型別的「方法」，因此呼叫這組方法便能轉換成其它型別。\nlet a = 1; // 宣告變數為number a.__proto__; // 顯示a可使用的函式 大家可以執行上面的程式碼，你會發現a有好幾種函式，接著可以展開[[Prototype]]，你會發現toString方法就在這裡。這就是為什麼每次在官方文件上找方法會看到像Number.prototype.toString()一樣長的原因。\n  可用函式  由於這牽涉到「物件原型」相互繼承的觀念，在這裡就不多做說明了，有興趣的朋友可以參考官方文件。\n轉型為布林型別：Boolean() 還記得前幾篇的[教學]UNDEFINED與NULL的比較曾提到過truth值與falsy值嗎？在這裡也需要用到喔～\n    truthy狀態 falsy狀態     布林值（Boolean） true false   字串（string） 除了空字串以外的字串 空字串   數字（number） 除了0之外的任意值 0   null、undefined 不可能 永遠   任何物件，包含{}、[] 永遠 不可能    接下來到了看圖說故事的時間，顯示為truthy就為true；falthy就歸類為false，就是這麼簡單！\n// boolean console.log(Boolean(true)); // 輸出：true console.log(Boolean(false)); // 輸出：false  // string console.log(Boolean(\u0026#34;字串\u0026#34;)); // 輸出：true console.log(Boolean(\u0026#34;1\u0026#34;)); // 輸出：true console.log(Boolean(\u0026#34;0\u0026#34;)); // 輸出：true console.log(Boolean(\u0026#34;\u0026#34;)); // 輸出：false  // number console.log(Boolean(123)); // 輸出：true console.log(Boolean(+0)); // 輸出：false console.log(Boolean(-0)); // 輸出：false console.log(Boolean(NaN)); // 輸出：false  // null console.log(Boolean(null)); // 輸出：false  // undefined console.log(Boolean(undefined)); // 輸出：false  // array console.log(Boolean([1,2,3])); // 輸出：true  // object console.log(Boolean({name: \u0026#34;Tom\u0026#34;, age: 18})); // 輸出：true 轉型為字串型別：toString()、String() String()與 .toString()都可以將值轉換為字串型別，差別在於後者在收到null、undefined和number時會報錯。 String()的程式碼：\n// boolean console.log(String(true)); // 輸出：\u0026#34;true\u0026#34; console.log(String(false)); // 輸出：\u0026#34;false\u0026#34;  // string console.log(String(\u0026#34;字串\u0026#34;)); // 輸出：\u0026#34;字串\u0026#34; console.log(String(\u0026#34;1\u0026#34;)); // 輸出：\u0026#34;1\u0026#34; console.log(String(\u0026#34;0\u0026#34;)); // 輸出：\u0026#34;0\u0026#34; console.log(String(\u0026#34;\u0026#34;)); // 輸出：\u0026#34;\u0026#34;  // number console.log(String(123)); // 輸出：\u0026#34;123\u0026#34; console.log(String(+0)); // 輸出：\u0026#34;0\u0026#34; console.log(String(-0)); // 輸出：\u0026#34;0\u0026#34; console.log(String(NaN)); // 輸出：\u0026#34;NaN\u0026#34;  // null console.log(String(null)); // 輸出：\u0026#34;null\u0026#34;  // undefined console.log(String(undefined)); // 輸出：\u0026#34;undefined\u0026#34;  // array console.log(String([1,2,3])); // 輸出：\u0026#34;1,2,3\u0026#34;  // object console.log(String({name: \u0026#34;Tom\u0026#34;, age: 18})); // 輸出：\u0026#34;Object Object\u0026#34; toString()的程式碼：\n// boolean console.log(true.toString()); // 輸出：\u0026#34;true\u0026#34; console.log(false.toString()); // 輸出：\u0026#34;false\u0026#34;  // string console.log(\u0026#34;字串\u0026#34;.toString()); // 輸出：\u0026#34;字串\u0026#34; console.log(\u0026#34;1\u0026#34;.toString()); // 輸出：\u0026#34;1\u0026#34; console.log(\u0026#34;0\u0026#34;.toString()); // 輸出：\u0026#34;0\u0026#34; console.log(\u0026#34;\u0026#34;.toString()); // 輸出：\u0026#34;\u0026#34;  // number console.log(123.toString()); // 輸出：Uncaught SyntaxError: Invalid or unexpected token console.log(+0.toString()); // 輸出：Uncaught SyntaxError: Invalid or unexpected token console.log(-0.toString()); // 輸出：Uncaught SyntaxError: Invalid or unexpected token console.log(NaN.toString()); // 輸出：\u0026#34;NaN\u0026#34;  // null console.log(null.toString()); // 輸出：Uncaught TypeError: Cannot read properties of null (reading \u0026#39;toString\u0026#39;)  // undefined console.log(undefined.toString()); // 輸出：Uncaught TypeError: Cannot read properties of undefined (reading \u0026#39;toString\u0026#39;)  // array console.log([1,2,3].toString()); // 輸出：\u0026#34;1,2,3\u0026#34;  // object console.log({name: \u0026#34;Tom\u0026#34;, age: 18}.toString()); // 輸出：\u0026#34;Object Object 在我看來要如何記得toString收到null、undefined和number時會報錯的方法就是「它這樣寫很奇怪」。\ntoString的寫法是把變數放在函式前面而非包在裡面，這就像我們不會把變數名稱開頭命名為數字，看起來就非常奇怪～（以上的想法僅供參考，如果不是請不要來打我QAQ\n不過，假如用變數來代表number，toString就可以用了，而null跟undefined依然不能用。\nlet a = 123; let b = null; let c; console.log(a.toString()); // 輸出：\u0026#34;123\u0026#34; console.log(b.toString()); // 輸出：Uncaught TypeError: Cannot read properties of null (reading \u0026#39;toString\u0026#39;) console.log(c.toString()); // 輸出：Uncaught TypeError: Cannot read properties of undefined (reading \u0026#39;toString\u0026#39;) 轉型為數值型別：Number()、parseInt()、parseFloat()  Number()：可以將「物件」轉化成數值。 parseInt()：可以傳回由「字串」轉換而成的整數。 parseFloat()：可以傳回由「字串」轉換而成的浮點數。  三者在遇到無法轉型的情況下，皆輸出NaN。\nNumber()的程式碼：\n// boolean console.log(Number(true)); // 輸出：1 console.log(Number(false)); // 輸出：0  // string console.log(Number(\u0026#34;字串\u0026#34;)); // 輸出：NaN console.log(Number(\u0026#34;1\u0026#34;)); // 輸出：1 console.log(Number(\u0026#34;0\u0026#34;)); // 輸出：0 console.log(Number(\u0026#34;\u0026#34;)); // 輸出：0  // number console.log(Number(123)); // 輸出：123 console.log(Number(+0)); // 輸出：0 console.log(Number(-0)); // 輸出：-0 console.log(Number(NaN)); // 輸出：NaN  // null console.log(Number(null)); // 輸出：0  // undefined console.log(Number(undefined)); // 輸出：NaN  // array console.log(Number([1,2,3])); // 輸出：NaN  // object console.log(Number({name: \u0026#34;Tom\u0026#34;, age: 18})); // 輸出：NaN parseInt()的程式碼：\n// boolean console.log(parseInt(true)); // 輸出：NaN console.log(parseInt(false)); // 輸出：NaN  // string console.log(parseInt(\u0026#34;字串\u0026#34;)); // 輸出：NaN console.log(parseInt(\u0026#34;1\u0026#34;)); // 輸出：1 console.log(parseInt(\u0026#34;0\u0026#34;)); // 輸出：0 console.log(parseInt(\u0026#34;\u0026#34;)); // 輸出：NaN  // number console.log(parseInt(123)); // 輸出：123 console.log(parseInt(+0)); // 輸出：0 console.log(parseInt(-0)); // 輸出：0 console.log(parseInt(NaN)); // 輸出：NaN  // null console.log(parseInt(null)); // 輸出：NaN  // undefined console.log(parseInt(undefined)); // 輸出：NaN  // array console.log(parseInt([1,2,3])); // 輸出：1  // object console.log(parseInt({name: \u0026#34;Tom\u0026#34;, age: 18})); // 輸出：NaN 仔細觀察上面的程式碼可以知道，Number()是將「物件」轉化成數值；parseInt()與parseFloat()是將「字串」轉化成數值，因此後者會輸出堆NaN，因為它們都不是字串。（沒有列parseFloat是因為它跟parseInt差不多，等等它就會出現了。\n不知道有沒有人眼尖發現在parseInt轉換陣列時，輸出的居然是數字？\n因為剛剛講的都還只是基本用法，有差別的地方現在才開始：\n Number()：若「物件」夾雜不可轉換的值時，則全部輸出為NaN。 parseInt()：忽略前後空白，在遇到字元被無法解析時，會忽略那個字元與後面的所有字元，停止解析，並回傳目前為止的結果。另外，它真正的寫法為parseInt(string, radix)前者為要轉換的目標值；後者代表使用哪種進位制轉換，為選填。 parseFloat()：只傳回第一個數字。前後空格會被省略。  // 數字在前面 console.log(Number(\u0026#34;9487就是狂\u0026#34;)); // 輸出：NaN console.log(parseInt(\u0026#34;9487就是狂\u0026#34;)); // 輸出：9487 console.log(parseFloat(\u0026#34;9487就是狂\u0026#34;)); // 輸出：9487  // 數字在後面 console.log(Number(\u0026#34;C8763\u0026#34;)); // 輸出：NaN console.log(parseInt(\u0026#34;C8763\u0026#34;)); // 輸出：NaN console.log(parseFloat(\u0026#34;C8763\u0026#34;)); // 輸出：NaN  // 數字前後有空白 console.log(Number(\u0026#34; 1 1 5 5 6 6 5\u0026#34;)); // 輸出：NaN console.log(parseInt(\u0026#34; 1 1 5 5 6 6 5\u0026#34;)); // 輸出：1 console.log(parseFloat(\u0026#34; 1 1 5 5 6 6 5\u0026#34;)); // 輸出：1  // 小數 console.log(Number(\u0026#34;9.2\u0026#34;)); // 輸出：9.2 console.log(parseInt(\u0026#34;9.2\u0026#34;)); // 輸出：9 console.log(parseFloat(\u0026#34;9.2\u0026#34;)); // 輸出：9.2 console.log(Number(\u0026#34;7.77\u0026#34;)); // 輸出：7.77 console.log(parseInt(\u0026#34;7.77\u0026#34;)); // 輸出：7 console.log(parseFloat(\u0026#34;7.77\u0026#34;)); // 輸出：7.77  // parseInt轉換進位制 console.log(parseInt(1011010, 2)); // 輸出：90，二進位 console.log(parseInt(1011010, 5)); // 輸出：16380，五進位 console.log(parseInt(1011010, 8)); // 輸出：266760，八進位 console.log(parseInt(1011010, 16)); // 輸出：16846864，十六進位 到這裡顯性轉型就告一段落了，接著來看看隱性轉型。\n隱性轉型 這是轉型中最GY的一個，因為它會自己幫你轉型，有時一個不注意，輸出的結果要嘛變成字串相加；要嘛變成NaN。還有很多奇奇怪怪例子，像是3\u0026lt;2\u0026lt;1會顯示true，這次就來讓我們好好了解其中的規則吧。\n 轉換為布林型別：比較運算子、邏輯運算子、條件（三元）運算子 轉換為字串型別：算數運算子 轉換為數值型別：算數運算子  這裡列出大多數會看到的情形，因為它不像顯性轉型一樣有固定的公式可言，因此只能大致歸納出幾點原因。\n轉換為布林型別：其實都是看truthy跟falsy值 老樣子，看到轉換為布林值就是要先上圖～\n    truthy狀態 falsy狀態     布林值（Boolean） true false   字串（string） 除了空字串以外的字串 空字串   數字（number） 除了0之外的任意值 0   null、undefined 不可能 永遠   任何物件，包含{}、[] 永遠 不可能    比較運算子、邏輯運算子、條件（三元）運算子這三者跟轉換為布林型別有關，但最關鍵的還是「truthy跟falsy值」身上，透過truthy跟falsy值轉換成true或是false，再透過剛剛的三條運算子來判斷。\n使用比較運算子：\n這裡使用一般相等（==跟!=）來比較，因為一般相等會幫忙轉型別；而使用嚴格相等（===跟!==）就不用玩了，需要型別與值都相同才會相同。\n    符號 說明     一般相等（equality operator） == 將比較值轉換成同型別後比較，再比較兩者的值。（如字串8等同於數字8）   一般不相等 != 將比較值轉換成同型別後比較，再比較兩者的值，值不同視為不相等。（如字串8不等同於數字7）   嚴格相等（identity operator） === 先看型別再看值，兩者的值不會轉換型別。   嚴格不相等 !== 兩個不同型別的值，視為不相等。（如字串8不等同於數字8）    let x = 1450; //宣告為number let y = \u0026#34;1450\u0026#34;; // 宣告為string let z = 377; //宣告為number  // 一般相等 console.log(x == y); // 輸出：true console.log(x == z); // 輸出：false console.log(x != z); // 輸出：true console.log(true == \u0026#39;1\u0026#39;); // 輸出：true console.log(false == \u0026#39;0\u0026#39;); // 輸出：true  // 嚴格相等 console.log(x === y); // 輸出：false console.log(x === z); // 輸出：false console.log(x !== z); // 輸出：true console.log(true === \u0026#39;1\u0026#39;); // 輸出：false console.log(false === \u0026#39;0\u0026#39;); // 輸出：false 這裡有個比較有趣的題目，跟比大小有關：\nconsole.log(1 \u0026lt; 2 \u0026lt; 3); console.log(3 \u0026lt; 2 \u0026lt; 1); 大家覺得答案會是什麼呢？（提示：比較運算子是一次比較兩個）\n準備公布答案了喔～\n3\u0026hellip;\n2\u0026hellip;\n1\u0026hellip;\n答案皆為true。程式的多個比較需要使用到邏輯運算子（\u0026amp;\u0026amp;或||），不能一整排刷過去R~\n// (1 \u0026lt; 2 \u0026lt; 3)會拆成這樣 1 \u0026lt; 2 //true true \u0026lt; 3 // true  // (3 \u0026lt; 2 \u0026lt; 1)會拆成這樣 3 \u0026lt; 2 // false false \u0026lt; 1 // true 使用邏輯運算子：\n邏輯運算子有AND、OR、NOT這三種，詳細使用方式請參考下表。\n   運算子 用法 描述     AND（\u0026amp;\u0026amp;） 運算式1 \u0026amp;\u0026amp; 運算式2 假如 運算式1 可以被轉換成 false的話，回傳 運算式1；否則，回傳 運算式2。 因此，\u0026amp;\u0026amp;只有在 兩個運算元都是True 時才會回傳 True，否則回傳 false。   OR（||） 運算式1 || 運算式2 假如 運算式1 可以被轉換成 true的話，回傳 運算式1；否則，回傳 運算式2。 因此，||在 兩個運算元有任一個是True 時就會回傳 True，否則回傳 false。   NOT（!） !運算式 假如單一個運算元能被轉換成True時，回傳false ， 不然回傳 true。    // \u0026amp;\u0026amp; console.log(true \u0026amp;\u0026amp; true); // 輸出：true console.log(true \u0026amp;\u0026amp; false); // 輸出：false console.log(false \u0026amp;\u0026amp; true); // 輸出：false console.log(false \u0026amp;\u0026amp; (3 == 4)); // 輸出：false console.log(\u0026#34;cat\u0026#34; \u0026amp;\u0026amp; \u0026#34;dog\u0026#34;); // 輸出：dog console.log(false \u0026amp;\u0026amp; \u0026#34;cat\u0026#34;); // 輸出：false console.log(\u0026#34;cat\u0026#34; \u0026amp;\u0026amp; false); // 輸出：false  // || console.log(true || true); // 輸出：true console.log(true || false); // 輸出：true console.log(false || true); // 輸出：true console.log(false || (3 == 4)); // 輸出：false console.log(\u0026#34;cat\u0026#34; || \u0026#34;dog\u0026#34;); // 輸出：cat console.log(false || \u0026#34;cat\u0026#34;); // 輸出：cat console.log(\u0026#34;cat\u0026#34; || false); // 輸出：cat  // ! console.log(!true); // 輸出：false console.log(!false); // 輸出：true console.log(!\u0026#34;cat\u0026#34;); // 輸出：false 使用條件（三元）運算子：\nlet x = 77; // 條件（三元）運算子 console.log(x ? \u0026#39;x為true\u0026#39; : \u0026#39;x為false\u0026#39;) // 輸出：x為true // 上面的程式碼等同於使用if else if (x){ console.log(\u0026#39;x為true\u0026#39;); // 輸出此行 } else{ console.log(\u0026#39;x為false\u0026#39;); } // 也可以加上驚嘆號，使其反轉成false console.log(!x ? \u0026#39;x為true\u0026#39; : \u0026#39;x為false\u0026#39;) // 輸出：x為false // 上面的程式碼等同於使用if else if (!x){ console.log(\u0026#39;x為true\u0026#39;); } else{ console.log(\u0026#39;x為false\u0026#39;); // 輸出此行 } // 也可以使用switch case let score = 92; switch (true){ case (score \u0026gt;= 90): console.log(`分數超過90分`); // 輸出此行  break; case (score \u0026gt;= 60 \u0026amp;\u0026amp; score \u0026lt; 90): console.log(`分數及格，但可以更好`); default: console.log(`不及格，要多讀書`); } 轉換為字串型別：使用加號 使用算數運算子時，+可以把數字相加，不過絕大多數我們都是將它作為字串相加，因為字串跟什麼相加都等於字串！！！\n// 跟boolean相加 console.log(\u0026#34;我是字串\u0026#34; + true); // 輸出：\u0026#34;我是字串true\u0026#34; console.log(\u0026#34;我是字串\u0026#34; + false); // 輸出：\u0026#34;我是字串false\u0026#34;  // 跟string相加 console.log(\u0026#34;我是字串\u0026#34; + \u0026#34;字串\u0026#34;); // 輸出：\u0026#34;我是字串字串\u0026#34; console.log(\u0026#34;我是字串\u0026#34; + \u0026#34;1\u0026#34;); // 輸出：\u0026#34;我是字串1\u0026#34; console.log(\u0026#34;我是字串\u0026#34; + \u0026#34;0\u0026#34;); // 輸出：\u0026#34;我是字串0\u0026#34; console.log(\u0026#34;我是字串\u0026#34; + \u0026#34;\u0026#34;); // 輸出：\u0026#34;我是字串\u0026#34;  // 跟number相加 console.log(\u0026#34;我是字串\u0026#34; + 123); // 輸出：\u0026#34;我是字串123\u0026#34; console.log(\u0026#34;我是字串\u0026#34; + (+0)); // 輸出：\u0026#34;我是字串0\u0026#34; console.log(\u0026#34;我是字串\u0026#34; + (-0)); // 輸出：\u0026#34;我是字串0\u0026#34; console.log(\u0026#34;我是字串\u0026#34; + NaN); // 輸出：\u0026#34;我是字串NaN\u0026#34;  // 跟null相加 console.log(\u0026#34;我是字串\u0026#34; + null); // 輸出：\u0026#34;我是字串null\u0026#34;  // 跟undefined相加 console.log(\u0026#34;我是字串\u0026#34; + undefined); // 輸出：\u0026#34;我是字串undefined\u0026#34;  // 跟array相加 console.log(\u0026#34;我是字串\u0026#34; + [1,2,3]); // 輸出：\u0026#34;我是字串1,2,3\u0026#34;  // 跟object相加 console.log(\u0026#34;我是字串\u0026#34; + {name: \u0026#34;Tom\u0026#34;, age: 18}); // 輸出：\u0026#34;我是字串[object object]\u0026#34; 轉換為數值型別：可以使用加號，但是小心使用 前面提到算數運算子的+常常被拿來和字串相加，因此若想要轉換成數值則需要注意相加的對象是否為字串。\n至於使用減乘除法（-、*、/）的情況，除了數值以外的其他基本型別都會透過Number()方法轉為數字。物件則在乘除的時候會透過Number()方法，轉為數字，在減法時透過valueOf()方法轉為數字。\n我們來看看使用加號會如何：\n// 使用加法 // 跟boolean相加 console.log(123 + true); // 輸出：124 console.log(123 + false); // 輸出：123  // 跟string相加 console.log(123 + \u0026#34;字串\u0026#34;); // 輸出：\u0026#34;123字串\u0026#34;，被轉成字串 console.log(123 + \u0026#34;1\u0026#34;); // 輸出：\u0026#34;1231\u0026#34;，被轉成字串 console.log(123 + \u0026#34;0\u0026#34;); // 輸出：\u0026#34;1230\u0026#34;，被轉成字串 console.log(123 + \u0026#34;\u0026#34;); // 輸出：\u0026#34;123\u0026#34;，被轉成字串  // 跟number相加 console.log(123 + 123); // 輸出：\u0026#34;246\u0026#34; console.log(123 + (+0)); // 輸出：\u0026#34;123\u0026#34; console.log(123 + (-0)); // 輸出：\u0026#34;123\u0026#34; console.log(123 + NaN); // 輸出：NaN，NaN與數值做運算會污染它，全部都會變成NaN  // 跟null相加 console.log(123 + null); // 輸出：123  // 跟undefined相加 console.log(123 + undefined); // 輸出：NaN  // 跟array相加 console.log(123 + [1,2,3]); // 輸出：\u0026#34;1231,2,3\u0026#34;，被轉成字串  // 跟object相加 console.log(123 + {name: \u0026#34;Tom\u0026#34;, age: 18}); // 輸出：\u0026#34;123[object object]\u0026#34;，被轉成字串 看到number使用加號被污染那樣，其他的運算子在同樣的算式估計也沒辦法活得好好的，這裡就列出可能會翻車的例子：\n// 使用減號 // string console.log(123 - \u0026#34;字串\u0026#34;); // 輸出：NaN console.log(123 - \u0026#34;1\u0026#34;); // 輸出：122 console.log(123 - \u0026#34;0\u0026#34;); // 輸出：123 console.log(123 - \u0026#34;\u0026#34;); // 輸出：123  // number console.log(123 - NaN); // 輸出：NaN  // null console.log(123 - null); // 輸出：123  // undefined console.log(123 - undefined); // 輸出：NaN  // array console.log(123 - [1,2,3]); // 輸出：NaN  // object console.log(123 - {name: \u0026#34;Tom\u0026#34;, age: 18}); // 輸出：NaN  // 使用乘號 // string console.log(123 * \u0026#34;字串\u0026#34;); // 輸出：NaN console.log(123 * \u0026#34;1\u0026#34;); // 輸出：123 console.log(123 * \u0026#34;0\u0026#34;); // 輸出：0 console.log(123 * \u0026#34;\u0026#34;); // 輸出：0  // number console.log(123 * NaN); // 輸出：NaN  // null console.log(123 * null); // 輸出：0  // undefined console.log(123 * undefined); // 輸出：NaN  // array console.log(123 * [1,2,3]); // 輸出：NaN  // object console.log(123 * {name: \u0026#34;Tom\u0026#34;, age: 18}); // 輸出：NaN  // 使用除號 // string console.log(123 / \u0026#34;字串\u0026#34;); // 輸出：NaN console.log(123 / \u0026#34;1\u0026#34;); // 輸出：123 console.log(123 / \u0026#34;0\u0026#34;); // 輸出：Infinite console.log(123 / \u0026#34;\u0026#34;); // 輸出：Infinite  // number console.log(123 / NaN); // 輸出：NaN  // null console.log(123 / null); // 輸出：Infinite  // undefined console.log(123 / undefined); // 輸出：NaN  // array console.log(123 / [1,2,3]); // 輸出：NaN  // object console.log(123 / {name: \u0026#34;Tom\u0026#34;, age: 18}); // 輸出：NaN 看來確實都會出問題呢，值得關注的是當數值除以null、0等概念為零的數值，輸出的竟然是無限大？？\n我在網路上找解答的時候也發現有趣的例子：\nconsole.log(0 / 0) // 輸出：NaN console.log(1 / 0) // 輸出：Infinite 這個就牽扯到浮點數一開始的定義，但是我還是不太懂，在這裡附上相關連結，有興趣的朋友可以研究看看。\n結語 前面講了這麼多，我們回過頭來複習一下：\n 強制轉型轉換出來的型別有：布林型別、字串型別、數字型別。 顯性轉型：有多種函式方法可以使用，轉換成布林型別注意truthy和falthy值；轉換成字串型別注意null跟undefined；轉換成數值型別注意函式方法的使用規則。 隱性轉型：自動轉譯成對應的型別，轉換成布林型別注意truthy和falthy值，轉換成字串型別通常都是用加號；轉換成數值型別使用算數運算子，但小心使用加號。  以上做個簡單的小整理。最後的貼心小建議就是盡量使用顯性轉型，比起隱性轉型的不確定性，使用顯性轉型至少還有個明確的函式方法讓你知道這裡有轉型～\n 參考資料 parseInt()、parseFloat() 與 Number()\nㄟ問你喔，強制轉型是什麼？轉換型別有規則可循嗎？(布林值、字串篇)\nㄟ問你喔，強制轉型是什麼？轉換型別有規則可循嗎？(數字型別篇)\n何謂強制轉型、以及如何作到轉換型別？\n",
    "ref": "/blog/20211030_explicit-coercion_implicit-coercion/"
  },{
    "title": "[教學]if else與switch case的比較",
    "date": "",
    "description": "別在if了，試試switch吧～",
    "body": "前言 在寫程式的時候如果要判斷東西，你第一個想到的是什麼語法？？我想絕大多數的人都會選擇用if else吧！因為我也是一樣～ 不過其實還有另一位弟兄可以寫判斷式，它就是最近剛發表的Switch啦！！！！！！（最近才剛收了一台二手switch，每次下班後都想拿起來玩，不想寫文章\u0026hellip;\u0026hellip;. 咳咳！扯遠了。這個switch case也能寫判斷式，所以這次就來比較看看兩者間的差異～\n 目錄：\n 語法差異 可讀性 嚴謹度 效能 使用時機   語法差異  if else：當條件成立的時候會執行其陳述式裡的程式，而不成立時則執行另外一個陳述式。 switch case：括號內放入表達式，接著就會表達式裡的值是否符合case條件，然後再執行此條件相關的陳述式。  // if else語法 if (條件式一){ // 若條件式一成立，則執行此區塊 } else if (條件式二){ // 若條件式二成立，則執行此區塊 } else{ // 若上述條件都不成立，則執行此區塊 } // switch case語法 switch (表達式){ case value1: //當 expression 的值符合 value1，則執行此陳述句  break; case value2: //當 expression 的值符合 value2，則執行此陳述句  break; ... case valueN: //當 expression 的值符合 valueN，則執行此陳述句  break; default: //當 expression 的值都不符合上述條件式，則執行此陳述句  break; } 從上面的程式碼可知，if else是將整個要判斷的內容放在條件式，其條件式是使用布林值作為判斷基礎，並且可以搭配邏輯運算子使用，例如：if ( a \u0026lt; 10 \u0026amp;\u0026amp; a \u0026gt;= 5)，這裡就代表如果變數a的值介於5~10之間，程式就會執行該區塊的內容；switch case的判斷方式則不同，它是將表達式的值與case裡的值做比較，其條件判斷是分佈在「表達式」與「case」裡。\n這裡特別講一下switch case也能夠做到區間判斷，就像if else語法一樣，但又不太一樣。\n讓我們看看傳統的if else是如何判斷區間：\nlet score = 77; if (score \u0026gt;= 90){ console.log(`分數超過90分`); } else if (score \u0026gt;= 60 \u0026amp;\u0026amp; score \u0026lt; 90){ console.log(`分數及格，但可以更好`); } else{ console.log(`不及格，要多讀書`); } // 輸出：分數超過90分 接著使用switch case的寫法，如果將if else的寫法搬過來使用，答案會是\u0026hellip;\nlet score = 82; switch (score){ case (score \u0026gt;= 90): // 92 !== true  console.log(`分數超過90分`); break; case (score \u0026gt;= 60 \u0026amp;\u0026amp; score \u0026lt; 90): // 92 !== false  console.log(`分數及格，但可以更好`); default: console.log(`不及格，要多讀書`); } // 輸出：不及格，要多讀書 什麼？為什麼會不及格？有哪邊出錯了嗎？其實這樣的判斷邏輯是對的，只是不了解switch case在比對的方法。\n剛剛前面有提到switch case的判斷方式為：「將表達式的值與case去做比對」，以上面的程式碼為例，第一個比較的就「表達式的是score」與「case的score \u0026gt;= 90」是否相等，這裡是用布林值來做判斷true或false，所以程式其實是以77 !== true來做判斷。\n由此可見，這樣的判斷寫法是錯誤的，因此程式就會繼續執行，最後因為所以條件都不符才會跑進default裡。\n到這裡希望大家可以先停下腳步，想想看若要改程式碼的話，應該要如何調整呢？（提示：想想判斷條件及布林值的比較）\n3\u0026hellip;\n2\u0026hellip;\n1\u0026hellip;答案揭曉：\nlet score = 92; switch (true){ case (score \u0026gt;= 90): // true === true  console.log(`分數超過90分`); break; case (score \u0026gt;= 60 \u0026amp;\u0026amp; score \u0026lt; 90): // true !== false  console.log(`分數及格，但可以更好`); default: console.log(`不及格，要多讀書`); } // 輸出：分數超過90分 很簡單的，表達式帶入的值不需要是變數本身，只需寫true即可，亦即需要判斷的事情就交給case，表達式只需等同於它即可。\n可讀性  if else：非常直覺，可套入人類的思考邏輯，如：「如果今天下雨，就要帶傘，沒有就不需要」，想到有什麼就寫什麼，之後若要再修改條件也是非常容易，因此很常被使用。 switch case：無法想到什麼就寫什麼，需要先仔細想想該如何應用。另外，在寫程式碼時還需注意加上break，程式才不會一直執行下去，假設判斷的東西變多，很有可能會有所遺漏。  這裡來看看若是沒加上break的話會有什麼結果：\nlet num = 2; switch(num){ case 1: console.log(`1`); case 2: console.log(`2`); case 3: console.log(`3`); case 4: console.log(`4`); case 5: console.log(`5`); } // 輸出：2 // 輸出：3 // 輸出：4 // 輸出：5 如果忘記加break，那麼程式會將所對應的case開始執行，然後持續執行之後的case，不論正確不正確。\nBTW，因為不想打太多case，剛剛嘗試用for迴圈來帶入case，並且「沒有加break」，想不到結果出乎意料：\nlet num = 2; for(let i = 1 ; i \u0026lt;= 5 ; i++){ switch(num){ case i : console.log(num); } } // 輸出：2 我預計會輸出「2,3,4,5」，結果卻輸出了「2」。\n於是我就上網爬文、找人求救，後來得到答案了。若用for迴圈包住switch case的話，程式碼會這樣執行：\nswitch(num){ case 2 : console.log(num); } switch(num){ case 3 : console.log(num); } switch(num){ case 4 : console.log(num); } switch(num){ case 5 : console.log(num); } 它會分開執行，不會將case包在同一個switch裡，所以沒加break就沒有差別了。\n嚴謹度  if else：不嚴謹，有時候會強制轉換裡面的參數。 switch case：嚴謹，在比較時使用「嚴格相等（===）」，需要在型別與值皆相同的情況下，才會成立。  let a = \u0026#34;2\u0026#34;; // if寫法 if (a == 1){ console.log(`a等於數字1`); } else if(a == 2){ console.log(`a等於數字2`); } else{ console.log(`a不是數字1、2`); } // 輸出：a等於數字2  // switch switch(a){ case 1: console.log(`a等於數字1`); case 2: console.log(`a等於數字2`); default: console.log(`a不是數字1、2`); } // 輸出：a不是數字1、2 一開始宣告變數為字串2，在if else裡會強制轉型為number去比較；而switch case就比較嚴格，要型別與值都相等的情況才成立。\n效能： 這裡來比較一下兩者的效能如何，這裡使用迴圈來重複計算無用的數據，最後輸出計算時間。\n// 宣告變數y為0 var y = 0; // 計算當下時間 var x1 = performance.now(); // 使用if else for (var i = 0; i \u0026lt; 10000000; i++) { for (var z = 0; z \u0026lt;= 4; z++) { if (z == 0) { y++; } else if (z == 1) { y--; } else if (z == 2) { y += 2; } else if (z == 3) { y -= 2; } else if (z == 4) { y += 3; } } } // 計算當下時間 var x2 = performance.now(); // 使用switch case for (var i = 0; i \u0026lt; 10000000; i++) { for (var z = 0; z \u0026lt;= 4; z++) { switch (z) { case 0: y++; break; case 1: y--; break; case 2: y += 2; break; case 3: y -= 2; break; case 4: y += 3; break; } } } // 計算當下時間 var x3 = performance.now(); console.log(`執行if else所花費的時間：${x2-x1}`); // 輸出：102.70000000298023 console.log(`執行switch case所花費的時間：${x3-x2}`); // 輸出：90.09999999403954 我的電腦輸出的時間可能會跟大家不一樣，有興趣的同學可以複製下來貼到瀏覽器上跑跑看，也可以改迴圈的執行次數（貼心小提醒：不要設太大，怕你點腦死去～\n現代的電腦都算強大的，通常switch case的執行時間會少於if else。基本上除非是專案需要大量的判斷，否則在效能上是看不出太大的差異。\nBTW，有時候if else的速度會比switch case還要快，因為它把會成立的條件放在前面，依序執行下去；而switch case則是以隨機訪問，因此有時候速度可能會比較慢。\nswitch case編譯後的執行流程大致如下：\n 將每一個case編譯後程式的首地址保存到一個陣列中。 根據傳入的值進行判斷，若存在就跳到索引的地址繼續進行；若不存在則直接跳到default。 其中的break直接跳到結尾處。    switch case流程  switch case利用陣列的隨機訪問，大大的增加判斷的效率，但是為了隨機訪問，會產生出一個陣列來保存地址，以空間換取時間來增加效率。\n使用時機 前面講了這麼多，到底要使用哪一個呢？\n其實並沒有哪一個比較好，哪一個比較爛。每個語法被創造出來都有它擅長的地方，我們需要視情況來使用。如果需要「範圍取值」，那就是if else的強項；如果是「確定取值」，那就是用switch case來處理。\n結語 最後稍微總結這兩者的差別。\n    if else switch case     可讀性 ✔︎ ✘   嚴謹性 ✘，會強制轉型 ✔︎，使用嚴格相等比較   效能 ✘ ✔︎   使用時機 範圍取值 確定取值     參考資料：\nif else 與 switch的使用時機\n[JavaScript] if 與 switch 的使用時機？\nHow to use switch statement inside for loop?\nJavaScript 的 if 跟 switch 效能\nJavaScript switch Statement - Dot Net Perls\n",
    "ref": "/blog/20211023_if-else_switch-case/"
  },{
    "title": "[教學]undefined與null的比較",
    "date": "",
    "description": "null的型別居然是object！這是Bug啊～這是Bug啊～這是Bug啊～",
    "body": "前言 今天繼續來打底練基礎～本次要來聊聊undefined、not defined、null，這些看起來就像「沒有」一樣，實際上他們之間可是差很多的哩！有些在時候會相等，有些時候又不一樣，那就跟著腳步一起看下去吧～～\n 目錄：\n 使用型態比較 truthy與falsy 使用一般相等與嚴格相等比較 使用數字運算比較 undefined與not defined的差別 undefined居然可以當作變數名稱或參數使用   使用型態比較 在寫JS時有兩大型別，分別是基本型別（Primitives）與物件型別（Object）。\n 基本型別： string、number、boolean、null、undefined、symbol 物件型別：array、object、function\u0026hellip;\u0026hellip;  在這裡可以觀察到本次要探討的null、undefined均出現在基本型別中。而基本型別裡都有「原始值 (primitive value)」，原始值是無法經過更改的的，例如布林值只有truth、false，不會再有其他的值，因此null、undefined也是一樣，null 型別只有一種值，就是 null ，而 undefined 類型也只有一種值，就是 undefined。\n我們透過程式碼來更進一步了解兩者之間的差異，首先分別給他們型別：\nlet a; let b = null; console.log(a) // 顯示：undefined，表示尚未賦值，未定義 console.log(b) // 顯示：null，表示此變數沒有值 undefined代表根本沒有這個東西，所以不知道這是什麼；null代表此變數（可能曾經有值，可能沒有值）現在沒有值。\n接著再用typeof來檢驗型別是不是undefined跟null:\nlet a; let b = null; console.log(typeof a) // 顯示：undefined console.log(typeof b) // 顯示：object 可以知道undefined 的型別是 undefined，null的型別是object。\n 誒，不是誒！剛剛不是說null 型別只有一種值，就是 null ？怎麼變成object？說變就變，不講武德誒！！！\n 既然有問題我們就去找找，從官方文件MDN Web Docs有說：\n The value null represents the intentional absence of any object value\u0026hellip;\nThe value null is written with a literal, null (it\u0026rsquo;s not an identifer for a property of the global object like undefined can be)\u0026hellip;\n 翻成白話文的意思就是「null是刻意指出一個值是『不存在的狀態』」，因此視為物件，只是它是個沒有值的物件（沒有值的意思不是0喔）。\n我這裡將兩者分別理解為：「undefined代表變數尚未被指派，呈現『尚未初始化的狀態』，因此型態為undefined；null代表變數已經被指派，但指派的值呈現『不存在的狀態』，因為已經被指派過了只是值尚未得知，若有值，型態就是object」\nnull的型態為object確實是強詞奪理，它其實就是有bug，而官方文件也有說這就是bug，此型態應該要是null才對！我們也只好先這樣接受了，也許等哪天就會改回來也說不一定（但修正會牽扯太多，我想這輩子應該是看不到吧）。\n到這裡先兩者的比較就先告個段落，因為我們要來認識新的東西，之後再比較才不會搞不清楚狀況。\ntruthy與falsy JS有truthy的概念，在某些情況下會被推斷為true，例如下列程式碼：\nif (123) { console.log(\u0026#39;沒有寫判斷居然就進來了\u0026#39;); // 顯示：沒有寫判斷居然就進來了 } 有時候我們在寫if else等判斷式，寫的會像上面的程式碼一樣。這裡的123就代表著true，這就是truthy。truthy的概念就像是「世間萬物皆有更古不變的道理，本就如此，而truthy就是如此，反之亦然」。以下有列表顯示在哪些情況下為truthy，而又在哪些情況下代表falsy：\n    truthy狀態 falsy狀態     布林值（Boolean） true false   字串（string） 除了空字串以外的字串 空字串   數字（number） 除了0之外的任意值 0   null、undefined 不可能 永遠   任何物件，包含{}、[] 永遠 不可能    這裡有個簡單的概念：「所有的物件都是truthy, 只有空字串、數字0、undefined和 null 會是falsy， 其餘的都是 truthy。」這裡要特別留意就算是「boolean（false）」它在if判斷之下，仍然為true喔！\n補充了有關truthy、falsy的知識點後，我們就可以繼續做比較了。\n使用一般相等與嚴格相等比較 等等我們會使用一般相等與嚴格相等來比較undefined、null是否相等。首先來看看一般相等與嚴格相等的差異：\n    符號 說明     一般相等（equality operator） == 將比較值轉換成同型別後比較，再比較兩者的值。（如字串8等同於數字8）   一般不相等 != 將比較值轉換成同型別後比較，再比較兩者的值，值不同視為不相等。（如字串8不等同於數字7）   嚴格相等（identity operator） === 先看型別再看值，兩者的值不會轉換型別。   嚴格不相等 !== 兩個不同型別的值，視為不相等。（如字串8不等同於數字8）     一般相等允許在等價性比較中進行強制轉換；嚴格相等則不允許強制轉換。\n 知道一般相等是比較值、嚴格相等比較型態和值（不能全然這樣說，正確說法是上面那條，這裡僅以大概的意思去詮釋）後，我們可以來做比較了：\nconsole.log(undefined == null); // 顯示：true 這裡使用一般相等來比較，兩者在轉換完型態後，其值是相等的。這裡我推測這是跟剛剛講的truthy、falsy有關，由於undefined和null都是falsy值，因此兩個falsy相等，得出的是true。\n為了避免被強制轉型，這裡建議使用嚴格相等來做比較：\nconsole.log(undefined !== null); // 顯示：false 這就比較正常了～嚴格相等從型別先下手，兩者的型別一個是undefined一個是object，是完全不同的，當然就不一樣囉！\n使用數字運算比較 前面透過型別、運算子來做比較，現在我們來用算數來比較它們的差異：\nlet a; let b = null; console.log(a + 1); // 顯示：NaN console.log(b + 1); // 顯示：1 undefined與任意數字運算都會是 NaN （Not a number）；null與任意數字運算時，null代表的值會是 0，因此可以運算。\nundefined與not defined的差別 這兩個都跟defined有關，但是卻是兩個完全不一樣的概念，前者已經知道是已給定變數名稱，卻還未賦值，英文直譯為『尚未被定義』；後者是「完全沒有者個東西～它連變數也沒有，哪來的定義可言，根本不存在」，因此為『沒有被定義』。\nundefined居然可以當作變數名稱或參數使用 驚不驚喜，意不意外～我們常說不能拿保留字當作變數，沒想到undefined居然打破這個限制！！！在非全域作用範圍下， undefined允許被當成變數名稱，而且變數的值是可以被修改的：\n// 當作變數名稱 (function() { var undefined = \u0026#39;foo\u0026#39;; console.log(`值為${undefined}，型別為${typeof undefined}`); // 顯示：值為foo，型別為string })() // 當作參數 (function(undefined) { console.log(`值為${undefined}，型別為${typeof undefined}`); // 顯示：值為foo，型別為string })(\u0026#39;foo\u0026#39;); 此舉雖然是合法的，但請不要使用好嗎？這樣會搞死一堆人 （除非你想欉康你的同事\n結語 講了這麼多，希望有幫助到各位了解undefined與null之間的差異，以下是整理表格：\n    值 型別 truthy or falsy 運算 當變數名稱、參數     undefined undefined undefined falsy 不能轉為數字並運算，會回傳NaN 可以   null null object falsy 可以轉為數字0運算 不可以     一般相等：相同，同為falsy值。 嚴格相等：不同，undefined與object是不同的型別。   參考資料：\nㄟ問你喔，null, undefined 和 not defined 是差在哪？\nJavascript 基礎打底系列 (二) - null、undefined、NaN 的差異與檢查方式\n重新認識 JavaScript: Day 03 變數與資料型別\n第29天-Truthy和Falsy\n",
    "ref": "/blog/20211019_undefined_null/"
  },{
    "title": "[教學]var、let、const之間的比較",
    "date": "",
    "description": "不要再亂設定變數了啊～設定好變數可以幫你減少bug喔！",
    "body": "前言 重新開始學習JS我才發現有很多小細節是需要好好打底的，所以我去報名了六角學院的Javascript工程師養成直播班從基礎開始學習，跟著老師的步調再加上每日作業、每週作業一定可以飛速成長的～\n接下來幾次的更新會注重在JS上，因為就連寫文章也是學習JS的一環（雖然我不確定能不能跟得上老師的進度生產文章，全職學習真的沒那麼多時間Ｒ～～ 但我還是會努力跟上進度的！\n本次探討的東西是非常基礎的宣告變數，但越是簡單的東西越要小心，魔鬼藏在細節中，你的程式碼出現bug很有可能就是因為變數使用錯誤的關係喔！今天就讓我們來了解var、let、const之間的差異吧～\n 目錄：\n 從ES5到ES6 變數的有效範圍 初始值（initializer） 作用域（scope） 重複賦值（reassigned） 重複宣告（redeclared） 變量提升（hoisting）   從ES5到ES6 什麼是ES5、ES6??\n在了解這兩者之間的差異前，我們需要先來認識ECMAScript。ECMAScript提供腳本語言需要遵守的細節、規則以及規範，ECMAScript每年都會發布一次新的版本，而比較知名的版本就是第五版的ES5以及第六版的ES6。\n 更詳細了解ECMAScript可以參考Day2 [JavaScript 基礎] 淺談 ECMAScript 與 JavaScript，裡面有詳細講解ECMAScript的歷史和制定流程。\n 目前的瀏覽器普遍支援ES5、ES6，甚至支援更新的ES7，大家可以安心使用。這裡我列出從ES5更新到ES6的主要改動：\n    ES5 ES6     類型 空值（null）、未定義（undefined）、布林值（boolean）、數字（number）、字串（string）、物件（object） 引入新的類型：符號（symbol）用來表示唯一值   變數 只能使用var來定義變數 新增let、const，能夠更嚴謹的定義變數   箭頭函數 使用function、return來定義函數內容 可用\u0026quot;=\u0026gt;\u0026ldquo;等符號代表function   迴圈 使用for迴圈、for in迴圈、forEach迴圈\u0026hellip; 新增for of迴圈    從上方表格可得知ES6是基於ES5上新增了部分的功能，而我們今天就先來探討變數的部分，其他的之後後再說（如果老師有出的話我就一定會更新 XDD~\n變數的有效範圍 宣告變數的位置是會影響到他們的作用範圍，有效範圍主要分成「全域變數」、「區域變數」兩種：\n 全域變數（Global Variable）：在函式外宣告的變數。整個程式中都可以被存取與修改。 區域變數（Local Variable）：在區塊內等被 { } 包起來的地方宣告的變數。此變數只能提供在所屬的function函式中執行，不提供給functionc函式以外呼叫使用，當function函式執行完後，記憶體只會保留其執行的結果，變數的部分則會被記憶體消除釋放掉。  var global_variable = \u0026#34;我是全域變數\u0026#34;; // 宣告全域變數 function show(){ var local_variable = \u0026#34;我是區域變數\u0026#34;; // 宣告區域變數  console.log(`在function內呼叫全域變數： ${global_variable}`); // 顯示：在function內呼叫全域變數： 我是全域變數  console.log(`在function內呼叫區域變數： ${local_variable}`); // 顯示：在function內呼叫區域變數： 我是區域變數 } show(); //呼叫函式  console.log(`在function外呼叫全域變數： ${global_variable}`); // 顯示：在function外呼叫全域變數： 我是全域變數 console.log(`在function外呼叫區域變數： ${local_variable}`); // 報錯：Uncaught ReferenceError: local_variable is not defined at \u0026lt;anonymous\u0026gt; 由上方的程式碼可以看出全域變數可以在整個程式碼內取得到；而區域變數只能在該函數（區域）取得，在函數（區塊）外就取得不到，因此會報錯顯示「not defined（沒有被定義）」。\n到這裡補充完ECMAScript、變數的有效範圍的相關知識，我們終於可以進到下一趴了～～\n初始值（initializer）  var、let不需要給初始值，它們的預設是undefined。 const必須有初始值，因為是常數，自然是要有固定不變的常量。  var var_initial // 顯示：undefined let let_initial // 顯示：undefined const const_initial // 報錯： Uncaught SyntaxError: Missing initializer in const declaration 作用域（scope）  函式作用域（function scope）：var屬函式作用域，唯有在函式（function）內才使用，作用範圍為區域性（local）；若在函式外宣告，其作用範圍就變成了全域性（global）。 塊級作用域（block scope）：let、const屬塊級作用域，以塊級（block）當作最小單位來切分，也就是用大括號{}來區分。  以下是函式作用域（function scope）的範例：\nfunction show() { var num = 1; console.log(num); // 顯示：1 } show(); // 呼叫函式 console.log(num); // 報錯：Uncaught ReferenceError: num is not defined at \u0026lt;anonymous\u0026gt; 再來對比塊級作用域（block scope）就可以知道兩者差在哪：\nfunction show() { let num1 = 1; const num2 = 2; console.log(num1); // 顯示：1  console.log(num2); // 顯示：2 } show(); // 呼叫函式 console.log(num1); // 報錯：Uncaught ReferenceError: num1 is not defined at \u0026lt;anonymous\u0026gt; console.log(num2); // 報錯：Uncaught ReferenceError: num2 is not defined at \u0026lt;anonymous\u0026gt; 上面的程式碼可以看到let、const並無法在函式外被呼叫，因為function的大括號也算是一種block scope。\n在if、else、for、while等塊級區域（block scope）使用var告變數是會污染全域變數的。我們來看看下列的程式碼：\nfor(var i = 0; i\u0026lt;3 ; i++){ console.log(i); //依序顯示：1、2 } console.log(i); // 顯示： 3 但我覺得那是工程師沒有仔細注意var是function scope，它的最小單位是以function來區分的，而if、else、for、while等塊級區域（block scope）則是以大括號{}來區分的，因此在block scope裡面的var當然會繼續往上加Ｒ～\n這裡再舉一個例子，這樣會比較好理解：\nfunction show1() { var i = 10; for(var i=0; i\u0026lt;3; i++){ console.log(i); // 顯示：1,2  } console.log(i); // 顯示：3 } show1(); // 呼叫函式 console.log(i); // 報錯：Uncaught ReferenceError: i is not defined at \u0026lt;anonymous\u0026gt; 從上面的程式碼可以了解var確實為function scope，因此在函式內的block scope是無法攔下i的，它會繼續增加；而在函式外面卻是找不到i的。\n重複賦值（reassigned）  var、let可以重複賦值，賦予的值稱「變數」，顧名思義是可以改變的數字。 const無法重複賦值，賦予的值稱「常數」，常數又稱定數，是指一個數值固定不變的常量，如圓周率等，這類的數值是無法經過改動的。  var a = 1; a = 2; let b = 2; b = 3; console.log(a); // 顯示：2 console.log(b); // 顯示：3  const c = 3; c = 4; // 報錯：Uncaught TypeError: Assignment to constant variable. at \u0026lt;anonymous\u0026gt; 這裡需要特別注意一點，const雖然不能夠重複賦值，但它若是「物件型別」的物件或陣列，則『看起來就能夠重複賦值』，但它並沒有！！！！！！！！\nlet arr1 = [1,2,3]; let arr2 = arr1; arr2.push(4); console.log(arr1); // 顯示：1,2,3,4 console.log(arr2); // 顯示：1,2,3,4 由上方的程式碼可以看到，在arr2新增4，結果arr1的值也發生了改動，這樣確實看起來像是const可以重複賦值。然而實際上卻不是如此，第二行程式碼的意思為將arr2「指向」arr1現在指向的記憶體位置，所以兩者皆指向同一個記憶體。「用 const 宣告的變數，不能改變其值」，對於 object 來說是指：「物件/陣列裡面存的 『記憶體位置』 不能改變」，因此這裡不會改變記憶體位置，改變的而是值。\n我之後會補上傳值、傳參考的文章，想要了解詳情之後可以去看看。\n重複宣告（redeclared）  var可以重複宣告。 let、const不可重複宣告。  var a = 1; var a = 2; console.log(a); // 顯示：2  let b = 1; let b = 2; // 報錯：Uncaught SyntaxError: Identifier \u0026#39;b\u0026#39; has already been declared  const c = 1; const c = 2; // 報錯：Uncaught SyntaxError: Identifier \u0026#39;c\u0026#39; has already been declared 變量提升（hoisting）  var能夠變量提升。 let、const無法變量提升。  console.log(a); var a = 1; console.log(b); let b = 2; // 報錯：Uncaught ReferenceError: b is not defined at \u0026lt;anonymous\u0026gt;  console.log(c); const c = 3; // 報錯：Uncaught ReferenceError: c is not defined at \u0026lt;anonymous\u0026gt; 簡單來說使用變量提升，程式碼就會自動幫你編譯：\nconsole.log(a); // 顯示：undefined var a = 1; // 以上程式碼等同於 var a; console.log(a); // 顯示：undefined a = 1; 以上程式碼可以理解為：「編譯階段會放入記憶體存著，但是只存宣告，不能存變數」。\n結語 最後稍微總結這三者的使用方式。\n var：不會受限在塊級作用域（block scope）內，可能會汙染全域變數。不管哪個作用域(Scope)都可以存取，可以重複宣告。 let：所宣告的變數只有在塊級作用域（block scope）內有效，不會產生全域變數，無法在同一層 Block 重複宣告變數。 const：具備 let所有的特性。在一開始宣告時就必定要指定給值，不然會產生錯誤，宣告後不能更改值。  最後放上整理大表格結束這一回合～\n    var let const     初始值（initializer） ✘ ✘ ✔︎   函式作用域（function scope） ✔︎ ✔︎ ✔︎   塊級作用域（block scope） ✘ ✔︎ ✔︎   重複賦值（reassigned） ✔︎ ✔︎ ✘   重複宣告（redeclared） ✔︎ ✘ ✘   變量提升（hoisting） ✔︎ ✘ ✘     參考資料：\nDay2 [JavaScript 基礎] 淺談 ECMAScript 與 JavaScript\n[ 技術筆記 ] JavaScript｜var / let / const 差異\n[JS學徒特訓班] JavaScript ES6 : var, let, const 差異\n",
    "ref": "/blog/20211013_var_let_const/"
  },{
    "title": "[軟體分享]BetterTouchTool",
    "date": "",
    "description": "BetterTouchTool教學、設置",
    "body": "前言 TouchBar文章第三篇！這次不唬爛，確確實實解放你的TouchBar！\n這次介紹的軟體是BetterTouchTool（簡稱BTT），這個東西我在[軟體分享]在TOUCH BAR上顯示歌詞！有稍微提到過，此次就讓我們來好好研究一下BTT到底能做什麼吧！\nPS：我想很多人會覺得之後就沒有人會再用TouchBar了，何必介紹BTT呢？但其實啊~BTT能做到的事不只有TouchBar的功能，它可以客製化各種手勢操控、鍵盤快捷鍵抑或是遠程操控\u0026hellip; 就算之後沒有TouchBar也還是能活得好好的～\n 目錄：\n BetterTouchTool介紹 安裝及購買liscense  安裝 購買liscense   安裝GoldenChaos-BTT 客製化BetterTouchTool控制項  GC-BTT設定  Presents HomeStrip MenuBar DockBadges   BetterTouchTool控制項調整     BetterTouchTool介紹 簡單說BTT是一個強大的軟體，它能在Mac上自定義各種輸入設備，像是觸控版、滑鼠手勢、鍵盤快捷鍵等等，這次我們使用到的是TouchBar的控制設定。\nBTT還有個專門的社群可以讓使用者互相討論～就算你不會設定、不會寫程式，只想當個伸手黨，這都沒問題～～BTT支援輸出/導入功能。在社群中有一堆大神們開發自己的設定，你只需要下載、導入，你的TouchBar就能變的強大無比！\n  BTT社群   如何發揮Touch Bar 真正的實力？\n這裡附上有關BTT的討論與介紹，我當初就是看到這則貼文就被推坑使用BTT的。但網路上分享BTT設定的文章少的可憐，而且大多都是英文版，很多人看到一定是望之卻步，更不用說控制項一大堆，介面複雜的跟什麼一樣。因此我才想要寫篇文章，手把手的教大家快速安裝BTT。接下來我們就開始設定ㄅ～\n安裝及購買liscense 安裝 進入BTT的官網選擇BetterTouchTool，點擊下載最新版本的就可以了。\n  下載BTT   下載完之後若無法打開，可能是Mac阻擋第三方App，需要去偏好設定裡調整。選擇「蘋果」選單 \u0026gt;「系統偏好設定⋯」，按一下「安全性與隱私權」，然後按一下「一般」，下方就可以強制打開。\n 購買liscense 這個軟體之前是免費的，後來就開始要收費，但金額倒也不是很貴，你都買得起一台Mac了，難道還買不起超好用的軟體嗎（笑～\nBTT購買liscense的方式有三種：\n 一般許可證（BetterTouchTool Standard License）：價格8.5美金。一般許可證將會收到2年之內的更新，2年之後你將無法得到更新，但可以永久使用你最後更新的版本。 終生許可證（BetterTouchTool Lifetime License）：價格20.5美金。終生許可證可以一直得到最新的更新並且永久使用。 Setapp訂閱（Setapp subscription）：走訂閱制，每月9.99美金。Settapp裡面有超過200的Apps可以使用，其中包含了BetterTouchTool。    BTT liscense  點擊前往購買Liscense\n完成購買後它會寄一封信到你的電子信箱裡，之後去App裡填寫密碼就完成了。（若是遺失liscense，可以在社群上面發文，留下當初連寫的email，它們那邊就會再寄給你～\n如果不想花錢，BTT也提供45天的免費試用，等用過覺得好用，之後再買也不遲。\n安裝GoldenChaos-BTT 裝好了BTT，接下來就要來裝別人寫好的設定～這裡我以GoldenChaos-BTT為範例。\n點擊「Latest stable version」的連結，我這次下載的版本為GoldenChaos-BTT 3.5.63，版本可能會你們看到的還要舊，但這不影響操作。\n  GoldenChaos-BTT下載  之後會轉跳到BTT社群的下載區，點擊右上方的「下載」或是「直接導入」都可以。\n  社群下載GoldenChaos-BTT  點擊下載的檔案就可以開始匯入了。\n  GoldenChaos-BTT導入    初始GoldenChaos-BTT  做到這步，TouchBar已經夠強大了。你可以做到這步就結束，或者是繼續下去客製化這些控制項。\n客製化BetterTouchTool控制項 GoldenChaos-BTT已經設定好非～常～多～的設定，但有些設定我們不需要，抑或是顯示方式不如我們預期，因此接下來將讓我麼來「魔改」它。\nGC-BTT設定 GC-BTT Settings是GoldenChaos-BTT專門控制TouchBar的簡易控制面板。它用介面化的方式呈現控制項的開關，直覺並且簡單，因此第一步我們就來介紹一下GC-BTT Settings能做些什麼。\n首先要叫出GC-BTT Settings，你可以在TouchBar上點選齒輪按鈕打開，或者是按快捷鍵「⌘⌥⇧P」來打開。\n  點選齒輪    GC-BTT Settings快捷鍵  GC-BTT Settings介面可以控制一般、顯示UI、首頁常駐型按鈕顯示、背景應用程式通知按鈕顯示等。修改完記得要按「Check Settings」才會儲存。\nGeneral  System Menu Bar：控制視窗上方要不要顯示GoldenChaos-BTT的LOGO。 Escape Key Style：是否常駐顯示「esc鍵」。 Modifier Strips：GoldenChaos-BTT預設按下Control、Option、Command會有對應的介面，是否需要關掉。 Extras：能夠使漂浮視窗對齊網格。    GC-BTT Settings-general  Presents 它可以設定TouchBar要顯示內容的數量，有預設、最少、社群推薦以及客製化可選，個人覺得用預設就好，不需要在其他設定，之後我們還有更進階的設定可以調整。\n  GC-BTT Settings-presents  HomeStrip 這裡控制首頁左邊會出現 控制項，有些可以接關閉隱藏、動態顯示，或是只顯示icon等等。我個人是把能關的關一關，能動態顯示就動態顯示。\n  GC-BTT Settings-homestrip  MenuBar 這裡能控制的就多了，他控制TouchBar右側的控制項按鈕，絕大多數是常駐的。我一樣是能關就關，能動態就開動態，只留需要的。\nBTW，音量鍵我只留靜音，若要調整音量大小就把「雙指放在TouchBar上左右移動」:螢幕亮度也數同樣的道理，「三指放在TouchBar上左右移動」就可以控制了。\n  GC-BTT Settings-menubar  DockBadges 這裡控制的東西皆為通知項的，若某個App有通知，TouchBar左側就會出現該App的按鈕。我個人是有用的App就都打開。\n  GC-BTT Settings-dockbadges  以上，基本的設定就到這邊。我建議先把這邊基礎的設定調好後「就不要再動了」，這很重要，因為調整這裡的東西有可能會讓「進階調整」的東西變不見！你想想它可以重置排版，之後調整的東西當然會不見Ｒ！\n接下來讓我們進入進階調整，這才是真正BTT設定東西的地方。\nBetterTouchTool控制項調整 這裡才是真正BTT難的地方，不過好在GoldenChaos-BTT已經幫我們設定基本的東西。我在這裡會提一些我常用的設定以及一些小技巧。\n首先先介紹介面。介面可以從視窗上方的BTT icon的「Configuration」來打開。\n  BTT-configuration    BTT介面  介面中左側第一列是群組，裡面有非常多控制項內容；左側第二列是控制項；第三列是該控制項的觸發操作，第四列則是根據你所點選的顯示對應的詳細內容。\n我以下方的樣式為例，我們的操作主要是放在1、2、4中。接下來是幾個我常用的小技巧：\n  預設TouchBar   打開/隱藏：有時候想要打開或隱藏某些設定。像是我不想在TouchBar上看到最左側的「全螢幕按鈕」，此時點選第一列的「Escape Keys」，選取第二列的「Esc/Fullscreen」，在鍵盤按下「Command + D」就可以打開或是隱藏該按鈕。    移除全螢幕  調換順序、按鈕寬高、調整字體大小/顏色：我想將時間放在最右邊，並且調整大小及顏色。在第一列選取「Menu Bar」，第二列選取「日期/時間Widge」，在第四列選取「Common」來調整    調換順序、按鈕寬高、調整字體大小、顏色  顯示順序調成「108」，按鈕背景色調成「淡綠色」，文字顏色調成「黑色」，字體大小調成「16」\u0026hellip;這裡有很多東西可以客製化成自己想要的樣式～\n  設定按鈕細項  調整時間顯示樣式：由於GoldenChaos-BTT是外國人開發的，顯示的時間樣式自然就跟我們不同。我想將時間改成「幾月幾日星期幾 幾點幾分」的這種樣式。我們需要在「針對Widget裡做調整」填上想要的日期格式：  M月d日 E H:mm 若要查詢其他種顯示方式可以到UNICODE LOCALE DATA MARKUP LANGUAGE查看。\n  設定時間格式  加入歌詞功能：由於這個操作比較複雜，詳情可以看[軟體分享]在TOUCH BAR上顯示歌詞！。  以上就是我常用的小技巧，若之後還有其他的設定，我會陸陸續續地補上來的～\n結語 BetterTouchTool真的是一個非常好用的軟體，它把大家視為浪費錢又沒什麼功能的TouchBar加入多種功能，除了平常的一般設定外，我在社群還有看到國外大神替音樂開發軟體寫一套專門的BTT套件，讓使用者一個按鍵就可以呼叫出需要的音符；或者顯示Covid-19的相關數據；還有顯示CNN的頭條\u0026hellip;\u0026hellip;BTT提供了一個平台供開發者製作想要的內容，大大的提升了TouchBar的可玩性！\n",
    "ref": "/blog/20210911_bettertouchtool/"
  },{
    "title": "[軟體分享]解放你的TouchBar！",
    "date": "",
    "description": "Play the game with TouchBar",
    "body": "前言 再過一兩個月，新版的MacBook Pro就要推出了（應該吧？ TouchBar被拿掉似乎已成事實，看來大家真的很不喜歡TouchBar呢～\n因此我決定再多發幾篇有關TouchBar的文來好好紀念它一下，一來是大家之後可能就不會看到它，二來是我寫TouchBar的文章有非～常～多～人瀏覽，不信的話可以去Google上搜尋TouchBar歌詞，沒意外的話我寫的文章是排在第一個！！！真的超級感動的～～沒看過的朋友可以點這個連結：[軟體分享]在TOUCH BAR上顯示歌詞！\n這次介紹的東西有點廢（笑～ 它其實沒有什麼太大的實質作用，頂多就是打發時間娛樂一下而已。這同時也是在做實驗，看看這麼廢的內容會不會有人搜尋、SEO排名會不會靠前、後台流量會不會又大爆發\u0026hellip;\u0026hellip;\n希望能給我一個滿意的流量！以下是本次會介紹的軟體。\n 目錄：\n 溫馨小提醒 Touché Pac-Bar TouchBarSpaceFight TouchBar-Piano TouchBarDino RunMarioRun TouchBarPong Touchbar_nyancat   溫馨小提醒 等等介紹的軟體都是第三方軟體，因此Apple會嘗試阻擋，以下是來自Apple的文件：\n 若您嘗試打開的 App 並未由識別之開發者向 Apple 登錄，便會收到警告對話框。這並不代表一定是 App 發生問題。例如，部分 App 是在開發者登錄其識別碼之前所撰寫的。然而，這些 App 並未經過檢查，macOS 也無法檢查這些 App 在發行之後是否曾損壞或被修改。\n 簡單來說只要軟體不是放在App Store上，那麼這些軟體都沒有被Apple檢測過，不能保證其安全性。因此需要使用者額外授權才能打開。\n 若要在 Mac 上更改這些偏好設定，選擇「蘋果」選單 \u0026gt;「系統偏好設定⋯」，按一下「安全性與隱私權」，然後按一下「一般」。\n 接著就點擊強制打開就可以了。\n若對於安全性有疑慮的朋友可以查看官方文件了解進一步的資訊。\nTouché 它可以讓TouchBar上的資訊同步到螢幕上，可以使用滑鼠點擊控制，除此之外也方便TouchBar的截圖。\nPS：不要覺得他很爛～等等你就不用一直盯著TouchBar來玩遊戲了（笑～\n前往下載\nPac-Bar   小精靈  有沒有玩過小精靈？我想大部分的人都有玩過吧！那我再問問，你有沒有在TouchBar上玩過小精靈？肯定沒有吧～～\nPS：你不要以為路線只有一條很簡單，難的很勒！\n前往下載\nTouchBarSpaceFight   太空射擊遊戲  使用方向鍵控制上下左右，空白鍵發射子彈，在你的TouchBar上也能玩到太空射擊遊戲！\nPS：只要一直射子彈就不會死，雖然浪費蠻多子彈的。\n前往下載\nTouchBar-Piano   使用TouchBar來彈鋼琴   顧名思義，就是讓你能在TouchBar上「彈鋼琴」此外它能調整音高，還提供128種樂器可供選擇。官方甚至說你可以下載Touché來玩玩看呢！\nPS：有誰的手指細到能夠用TouchBar來彈琴嗎==\n前往下載\nTouchBarDino    小恐龍遊戲    小恐龍遊戲實測  通常要在沒有網路的情況下才能玩到小恐龍，現在你有更好的選擇！不但讓你能連網玩，還能在TouchBar上遊玩！！！\nPS：小恐龍跳起來的觸發並非按下的瞬間，而是離開的瞬間，所以需要習慣一下～\n前往下載\nRunMarioRun   在TouchBar上玩跑跑馬力歐  跟跑跑小恐龍有異曲同工之妙，它可以使用空白鍵跳躍，比TouchBar版的跑跑小恐龍還要好用。\nPS：不過撞到怪物後程式好像會死掉（不知道是不是我的電腦的問題？\n前往下載\nTouchBarPong   對打拼乓  我認為這算是裡面最好玩的遊戲！除了放在GitHub上的免費版外，他還有放在App Store上，價格是美金1.99元，折成台幣大約是70元。\nApp Store上的付費版功能：\n 電腦會根據玩家的實力越來越困難 三種模式可供選擇 本機雙人遊玩模式 沒有TouchBar也能玩  App Store付費版下載、GitHub免費版下載\nTouchBreakout    打磚塊遊戲    打磚塊遊戲實測  跟前一個的遊戲大同小異，一樣也有在App Store上販售，價格倒是比較便宜，折成台幣約33元。\nPS：作者還有手把手教你如何用Swift做出這個遊戲呢！\nApp Store付費版下載、GitHub免費版下載\nTouchbar_nyancat   nyancat  nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～\nPS：nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～nyan～\n前往下載\n結語 以上～希望大家會喜歡！玩得開心～\n 圖片來源：\n圖片均來自於個作者的GitHub、網站等\n",
    "ref": "/blog/20210831_touchbar_games/"
  },{
    "title": "舊鞋救命",
    "date": "",
    "description": "Step30",
    "body": "自從完成台灣公益資訊中心的專案後，主管覺得我可以勝任另一個專案，也就是各位現在看到的舊鞋救命。這個案子前前後後花費將近一年的時間才上線，在這個案子中可以說是我學習到最多的地方，很多不懂的、有問題的都是靠Google。製作的當下雖然很累，但我還是樂在其中。讓我印象最深刻的是當時我還只是個實習生，還需要公司、學校兩邊跑，有好幾次老師在台上講課，我則在台下製作這個專案，甚至還被朋友說有病==\n回過正題，「舊鞋救命」收集大家不需要的鞋子、衣物並且加以整理，再將這些物資帶到非洲給當地的人們穿；他們也有教導當地的人民如何耕種、協助開發水井等等，是個以「人道援助行動為基礎」的公益團體。歡迎大家多多支持他們，若是不想花摳摳的也可以報名志工或是捐舊衣物給他們～\n  step30  附上網站連結\n",
    "ref": "/portfolio/step30/"
  },{
    "title": "[軟體分享]在touch bar上顯示歌詞！",
    "date": "",
    "description": "Show Lyrics on Touch Bar",
    "body": "前言 大家好，最近忙的事情差不多都告一段落了，就來分享兩個讓touch bar能夠顯示歌詞的軟體吧！兩者各有各的優缺點，安裝方式也不一樣，就讓我們繼續看下去吧！\n 目錄：\n LyricsX touchbar_lyric   LyricsX 這個軟體能在App store上找到，它是一套能夠支援iTunes、Spotify、Vox、Audirvana、Swinsian等串流軟體，自動搜尋相對應的歌詞，並且可以設定歌詞要提前或延後顯示，還可將簡體中文自動翻譯成繁體中文，功能非常豐富。LyricsX提供多種呈現方式，但本次僅介紹如何將它應用在touch bar上。\n在App store上的LyricsX是閹割版的，並不支持touch bar歌詞功能，必須從LyricsX的Github上下載。\n附上網站連結\n  下載最新版本的zip檔  下載LyricsX的壓縮包，並且點開執行。此時會跳出一個警告視窗，提醒說是否要打開。\n  授權打開LyricsX  若打不開，請去系統偏好設定裡強制打開。點擊「蘋果鍵 \u0026gt; 系統偏好設定⋯ \u0026gt; 安全性與隱私權 \u0026gt; 一般」，按下強制打開就可以了。\n＊貼心小提醒：因為軟體不是從App store上載下來的，所以他的位置是在「下載項目」，記得把他拖曳到「應用程式」喔！\n基本上就安裝完成了。如果你剛好在播放音樂，那麼歌詞就已經出現在桌面上囉！接著我們要把歌詞塞在touch bar裡。\n  歌詞會顯示在桌面上  點選上方選單列LyricsX的icon，並且選擇偏好設定。\n＊貼心小提醒：在這裡可以把「啟用動態歌詞」關閉，畢竟一直出現在視窗上有點煩人\n  關閉桌面歌詞並且進入偏好設定  裡面有很多東西可以設定，像是偏好的音樂播放器、雙語歌詞、轉為繁中等等，各位可以依照自己的使用情境來設定。\n接著進入「實驗功能」必且把「啟用Touch Bar歌詞」打開，如此一來就可以在touch bar上顯示歌詞了。\n  啟用touch bar歌詞  此時的touch bar會出現LyricsX的icon，點擊它之後歌詞就會跑出來了。\n  點選icon    歌詞出現！  touchbar_lyric 這個軟體是需要搭配BetterTouchTool來使用的。簡單來說BetterTouchTool可以完全客製化touch bar的內容，多了很多彈性，當然設定也就蠻複雜的，網路上有很多別人做好的設定，下載下來並且根據自己需要的情境做設定是最快的方法。，由於設定BetterTouchTool需要花很長的篇幅來講解，這裡僅分享如何安裝歌詞的外掛到BetterTouchTool上，BetterTouchTool的安裝設定就不多贅述了，說不定哪天我心情好就來寫～\n此次的安裝需要打一些程式碼，稍微有些難度，但我們會一步一步慢慢來。\n我們使用homebrew來安裝python3，之後再去安裝touchbar_lyric。將此段程式碼貼到終端機上。\n/bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot; 安裝好homebrew之後，接著來安裝python3。一樣將下列程式碼貼到終端機上。\nbrew install python3 在終端機輸入下列程式碼：\npip3 install touchbar_lyric --upgrade 安裝完成之後，複製以下文字，之後直接貼在BetterTouchTool。\n[ { \u0026quot;BTTWidgetName\u0026quot; : \u0026quot;Lyric\u0026quot;, \u0026quot;BTTTriggerType\u0026quot; : 642, \u0026quot;BTTTriggerTypeDescription\u0026quot; : \u0026quot;Shell Script \\/ Task Widget\u0026quot;, \u0026quot;BTTTriggerClass\u0026quot; : \u0026quot;BTTTriggerTypeTouchBar\u0026quot;, \u0026quot;BTTPredefinedActionType\u0026quot; : -1, \u0026quot;BTTPredefinedActionName\u0026quot; : \u0026quot;No Action\u0026quot;, \u0026quot;BTTShellScriptWidgetGestureConfig\u0026quot; : \u0026quot;\\/bin\\/sh:::-c:::-:::\u0026quot;, \u0026quot;BTTEnabled2\u0026quot; : 1, \u0026quot;BTTRepeatDelay\u0026quot; : 0, \u0026quot;BTTUUID\u0026quot; : \u0026quot;93C8B565-73C7-49BE-960A-4FCF512CE881\u0026quot;, \u0026quot;BTTNotesInsteadOfDescription\u0026quot; : 0, \u0026quot;BTTEnabled\u0026quot; : 1, \u0026quot;BTTModifierMode\u0026quot; : 0, \u0026quot;BTTOrder\u0026quot; : 0, \u0026quot;BTTDisplayOrder\u0026quot; : 99, \u0026quot;BTTMergeIntoTouchBarGroups\u0026quot; : 0, \u0026quot;BTTTriggerConfig\u0026quot; : { \u0026quot;BTTTouchBarFreeSpaceAfterButton\u0026quot; : 0, \u0026quot;BTTTouchBarOnlyShowIcon\u0026quot; : false, \u0026quot;BTTTouchBarButtonColor\u0026quot; : \u0026quot;0.000000, 0.000000, 0.000000, 255.000000\u0026quot;, \u0026quot;BTTTouchBarApplyCornerRadiusTo\u0026quot; : 0, \u0026quot;BTTTouchBarItemPlacement\u0026quot; : 0, \u0026quot;BTTTouchBarAppleScriptStringRunOnInit\u0026quot; : true, \u0026quot;BTTTouchBarAlwaysShowButton\u0026quot; : false, \u0026quot;BTTTouchBarFontColorAlternate\u0026quot; : \u0026quot;0.000000, 0.000000, 0.000000, 255.000000\u0026quot;, \u0026quot;BTTScriptType\u0026quot; : 0, \u0026quot;BTTTouchBarButtonWidth\u0026quot; : 550, \u0026quot;BTTTouchBarScriptUpdateInterval\u0026quot; : 1, \u0026quot;BTTTouchBarItemIconHeight\u0026quot; : 22, \u0026quot;BTTTouchBarButtonUseFixedWidth\u0026quot; : 0, \u0026quot;BTTTouchBarButtonTextAlignment\u0026quot; : 1, \u0026quot;BTTTouchBarAlternateBackgroundColor\u0026quot; : \u0026quot;0.000000, 0.000000, 0.000000, 255.000000\u0026quot;, \u0026quot;BTTTBWidgetWidth\u0026quot; : 400, \u0026quot;BTTTouchBarItemIconWidth\u0026quot; : 22, \u0026quot;BTTTouchBarShellScriptString\u0026quot; : \u0026quot;$PYTHONPATH -m touchbar_lyric --app Spotify\u0026quot;, \u0026quot;BTTTouchBarIconTextOffset\u0026quot; : 5, \u0026quot;BTTTouchBarButtonFontSize\u0026quot; : 12, \u0026quot;BTTTouchBarFontColor\u0026quot; : \u0026quot;156.000006, 226.000002, 90.000002, 255.000000\u0026quot;, \u0026quot;BTTTouchBarButtonName\u0026quot; : \u0026quot;Lyric\u0026quot;, \u0026quot;BTTTouchBarButtonCornerRadius\u0026quot; : 6, \u0026quot;BTTTouchBarItemPadding\u0026quot; : 20 } } ] 接著在Script裡面填上：\n/usr/local/Cellar/python@3.9/3.9.4/bin/python3.9 -m touchbar_lyric --app Music --traditional    script設定  這裡講解一下程式碼。\n 剛剛用homebrew下載的python會放在Cellar的資料夾裡，每個人下載的版本可能會略微不同，但道理是一樣的，選擇python的路徑就對了。 這裡偵測Apple Music播放器，若使用Spotify當作主要的播放器，將程式碼的「Music」代換成「Spotify」就可以了。 最後的「traditional」是將簡體中文轉換成繁體中文。  到這裡基本的設定就設定完成了，若要更改文字顏色、文字大小及背景顏色等等可以在「Common」裡面設定。\n  設定文字大小、顏色、背景色  結語 LyricsX跟touchbar_lyric兩者我都有使用，不過後都用後者居多，畢竟我有在用BetterTouchTool嘛～這兩者我用過，以下是我的心得感想。\nLyricsX的優點：\n 方便安裝，操作簡易 有多種控制選項 可以控制歌詞提早、延後出現的時間  LyricsX的可改進的有：\n 自動轉成繁體中文的功能常常失靈  touchbar_lyric的優點：\n 可搭配BetterTouchTool使用 歌詞支持繁體中文  touchbar_lyric可改進的有：\n 安裝過程麻煩 歌詞有時候會出錯 歌詞出現時間過晚 可偵測的播放來源過少  以上就是這次的分享，若有問題也可以在底下留言互相討論喔！\n 參考資料：\nLyricsX\ntouchbar-lyric\n",
    "ref": "/blog/20210426_touchbar_lyrics/"
  },{
    "title": "台灣公益資訊中心",
    "date": "",
    "description": "Taiwan NPO Information Platform",
    "body": "新版的台灣公益資訊中心已經上線了一段時間了，在這裡先介紹這個網站的功用，它是台灣最大的公益社群入口，免費提供非營利組織發佈公益新聞、活動以及人才招募等等，新版也加入了義賣平台、補助公告等等新內容，目的在於加強公益團體的資訊流通及行銷，縮減公益團體的數位落差，提升非營利組織的曝光。\n這個專案可以說是我的處女作，第一次寫網頁就接手這麼大的專案，那時的壓力真的蠻大的\u0026hellip;\u0026hellip;.現在回頭來看看就覺得蠻有成就感的了。「在什麼都還不熟的情況下接手專案能讓人快速進步」這是我做完這個專案後得到的心得，儘管還有很多地方不足的，但凡走過必留下痕跡，未來再有類似狀況也知道要朝哪個方向修正。\n  Taiwan NPO Information Platform  附上網站連結\n",
    "ref": "/portfolio/npo/"
  },{
    "title": "[教學]Grid",
    "date": "",
    "description": "可以二維排列的Grid",
    "body": "前言 grid是一個很好用的排版工具之一，他甚至比flex好用呢！兩者之間有相似也有不相似的地方，就讓我們繼續看下去吧！\ngrid的包法與flex一樣，需要有外層的.container，也需要有內層的.items，若不懂內外層之間的關係，可以去看看我之前寫的[教學]FLEXBOX。\n照慣例，先來看看Container、Items的屬性有哪些：\n Container：\n Display Grid-template-columns_rows Grid-template-areas Grid-gap Justify-items Align-items  Items：\n Grid-column_row Justify-self Align-self   Container 跟flex一樣，grid大都是在container裡面下指令。\nDisplay 先宣告要使用grid來排版。\n\u0026lt;!-- css --\u0026gt; .container{ display: grid; } grid不像flex一下display就會有變化，它還需要把空間切成一塊一塊的才能使用，雖說有些麻煩，但事後在定位排版上會比較好操作，靈活度也比flex還要來得高。\nGrid-template-columns_rows Template的意思為模板，我們透過這個屬性把想要的區塊切開。它的語法主要分兩個：\n\u0026lt;!-- css --\u0026gt; grid-template-columns: 100px 50px auto 200px 1fr; \u0026lt;!-- 直行 --\u0026gt; grid-template-rows: 25% 100px 1fr; \u0026lt;!-- 橫列 --\u0026gt;   ＊給定的值可以使用px、%、fr等長度單位\n我們從左至右看，可以發現每一格的寬度是「100px 50px auto 200px 1fr」，這不就跟css內的grid-template-column一樣嗎！它的意思是「切幾格，每格自己給定」，以剛剛的例子來說就是切五格，每格的長度按照裡面的值所定。同理grid-template-rows也是如此。\nGrid-template-areas 這東西像是給定切好的區塊一個名字，之後在items叫它去該區塊。在Container裡先設好模版該長什麼樣、該叫什麼名字，每個格子裡要放哪個items。\n\u0026lt;!-- css --\u0026gt; .container{ grid-template-areas: \u0026#34;header header header header\u0026#34; \u0026#34;main main . sidebar\u0026#34; \u0026#34;footer footer footer footer\u0026#34;; } .item1{ grid-area: header; } .item2{ grid-area: main; } .item3{ grid-area: sidebar; } .item4{ grid-area: footer; } 上面的例子就是把Container切成4欄，第一列統一都是header；第二列main佔2欄，之後的為空白，最後一欄是sidebar；第三列皆為footer。而Items就分別帶入各自的名字。\n ＊空白的地方以\u0026quot;.\u0026ldquo;代替\nGrid-gap 這個功能類似上次提到flex的gap，若不知道在講什麼的朋友可以先來看看[教學]GAP再來了解。\ngrid-gap好用的地方在於它的彈性更多，safari也能夠讀取。它有三種寫法，column-gap及row-gap分別控制行、列之間的間隙，而grid-gap是兩個我都要！一次控制行列的間隙。\n\u0026lt;!-- css --\u0026gt; column-gap: 10px; \u0026lt;!-- column之間的間隙為10px --\u0026gt; row-gap: 15px; \u0026lt;!-- row之間的間隙為15px --\u0026gt; grid-gap: 20px; \u0026lt;!-- 所有格子之間的間隙為20px --\u0026gt; 值得注意的是，這裡給定的值是會影響整個寬度的喔！舉例來說，grid-template-column: 50% 50%，如果我們加上column-gap: 50px，那麼寬度是會炸開的，因為他們的總和超過100%了。\n所以我通常使用fr的單位，變成grid-template-colum: 1fr 1fr就不會有這個問題了。fr的概念可以想像成「將剩餘的空間按照比例去分配」，以grid-template-colum: 1fr 1fr為例，1+1=2，所以每一份間隔皆為1/2。\n那麼依樣畫葫蘆，grid-template-colum: 1fr 2fr 3fr每一欄的寬度分別為1/6，2/6，3/6，是不是蠻簡單的～\nJustify-items   justify-items  此功能與flex的justify-content類似，同樣是控制items水平靠左、置中、靠右。grid不用控制主軸與次軸，因此justify-content就是控制「水平」方向的排版。\n\u0026lt;!-- css --\u0026gt; justify-items: start; \u0026lt;!-- 靠左 --\u0026gt; justify-items: end; \u0026lt;!-- 靠右 --\u0026gt; justify-items: center; \u0026lt;!-- 置中 --\u0026gt; justify-items: stretch; \u0026lt;!-- 伸展 --\u0026gt;   ＊使用stretch時，不可控制裡面的大小，不然會調不動\nAlign-items   align-items  這個功能就跟flex的align-items一模模一樣樣～直接輕鬆套用！\n\u0026lt;!-- css --\u0026gt; align-items: start; \u0026lt;!-- 靠上 --\u0026gt; align-items: end; \u0026lt;!-- 靠底 --\u0026gt; align-items: center; \u0026lt;!-- 置中 --\u0026gt; align-items: stretch; \u0026lt;!-- 伸展 --\u0026gt;   ＊使用stretch時，不可控制裡面的大小，不然會調不動\n到這裡其實可以發現grid的排版方式其實比flex簡單很多，flex光是方向在那邊換來換去就已經搞死不少人了，而grid一次控制好兩邊，功能可以做到很複雜但依然好懂！\ncontainer的功能就先到這裡告一段落了，雖然還有其他的功能，但我覺得不常用，因此就沒放上來了（其實就是懶得寫啦哈哈哈哈\nGrid-column_row grid將container切成網格狀，再把items一個一個塞入每格的格子裡，若想把其中的一個items塞入好幾格格子，我們可以使用grid-template-areas來命名格子的名稱，再把items一次塞進去。這裡有個更好用的方法就是使用grid-colum以及grid-row。\n我們使用grid-colum以及grid-row來刻出上面grid-template-areas的版面吧！\n 範例當中我們把每列切成4欄。header需要把第一列佔滿，因此為grid-colum: 1/5，我們把每列切成4塊，所以會有5條線，也就是範例當中的黃線，由左至右分別為1~5，那麼1/5的意思就是從第1條線到第5條線。\n再來看看sidebar，它需要在最右邊，假設沒有控制他的話它就會接著前面的格子繼續排下去。因此它的grid-colum為4/5。\n此範例僅使用grid-colum而已，若和grid-row搭配可以產生出更多樣的排版方式。\nJustify-self   justify-self  justify-self是控制item自己的水平排版，這可是flex所沒有的屬性，flex根本不給排啊～\n\u0026lt;!-- css --\u0026gt; justify-self: start; \u0026lt;!-- 靠左 --\u0026gt; justify-self: end; \u0026lt;!-- 靠右 --\u0026gt; justify-self: center; \u0026lt;!-- 置中 --\u0026gt; justify-self: stretch; \u0026lt;!-- 延伸 --\u0026gt;   ＊此範例container使用水平、垂直置中，justify-self下的指令會壓過外層container\nAlign-self   align-self  來到最後一個屬性：align-self，是控制item自己的垂直排版，這屬性flex倒是有的，用法其實也一模一樣～\n\u0026lt;!-- css --\u0026gt; align-self: start; \u0026lt;!-- 靠上 --\u0026gt; align-self: end; \u0026lt;!-- 靠底 --\u0026gt; align-self: center; \u0026lt;!-- 置中 --\u0026gt; align-self: stretch; \u0026lt;!-- 伸展 --\u0026gt;   ＊此範例container使用水平、垂直置中，align-self下的指令會壓過外層container\n結語 grid的用法很多變，每次有版面切不出來時我通常都會用grid來切，如果切不出來的話\u0026hellip;那就把grid、flex混搭一起用，效果更好！\nBTW，最近真的有夠忙的，近期應該不會再更新這種教學了，要花費豪多時間呢！之後應該會更新一些小教學，至於是什麼呢～我也不知道，因為根本還沒想哈哈哈，就這樣了，ㄅㄅ～\n 參考資料：\nA Complete Guide to Grid\n",
    "ref": "/blog/20210205_grid/"
  },{
    "title": "[教學]Gap",
    "date": "",
    "description": "Gap:「請做好社交距離」",
    "body": "前言 在上一篇文章中講解了如何用flex排版，如果還沒看過的話請去看[教學]FLEXBOX再來看這篇文章喔。\n各位在使用Flex時有沒有發生過Container裡面的items都會黏在一起、擠在一起的情況呢？這時我想大家的處理方式應該都是在items下外距來隔開吧！這次要介紹的就是超級方便的gap，他可以快速控制的items的之間的間隔喔！\nGAP 它使用的方式非常簡單，只要在Container裡加上：\n\u0026lt;!-- css --\u0026gt; .container{ gap: 20px; } 好，結束收工。\n484很～～～～～～簡單。\n 但是\u0026hellip;我用safari看完全沒有間隔R，東西還是黏在一起誒。為什麼會這樣子？\n 我們可以去查一下gap語法的支援程度如何。\n  gap的支援程度  恩\u0026hellip;滿江紅一片呢，這代表還有很多瀏覽器不支援，各位請加油好嗎？\n在各瀏覽器普遍還沒支援的情況下，我們可以換一種寫法，讓沒有不支援的瀏覽器也能呈現出gap的樣式。\n修改後的GAP 為了達到目的，我們必須從Container跟items下手。\n\u0026lt;!-- css --\u0026gt; .container{ display: flex; flex-wrap: wrap; --gap: 20px; margin: calc(-1 * var(--gap)) 0 0 calc(-1 * var(--gap)); } .container \u0026gt; *{ margin: var(--gap) 0 0 var(--gap); } ＊--gap這個東西css裡面的變數，我們將想要的間隔寬度存在這裡，之後要改大小就只需在這裡處理就好。\n它的原理很簡單，以items來說，彼此之間都要有距離，因此每個items都需要在「上方」及「左側」有外距，但如次一來在「上方第一橫排的items」跟「左側第一直排的items」就會跟Container產生間隔。\n這時就換Container來處理問題。我們只需把Container「上方」及「左側」的外距再縮回來就能達到這個效果了。\n ＊2021/06/04更新：現在Safari也已經支援使用gap了，上面的東西大家看看就好。\n結語 其實我比較希望各家瀏覽器能快快支援gap，但目前也只能先以修改外距來達到類似的效果。不過不用灰心，因為除了gap能控制間隔外，還有另一個也能控制間隔的語法，不過這並不在flex的範疇裡，而是在更方便的grid裡，之後會陸陸續續地放上來喔～\n",
    "ref": "/blog/20201120_gap/"
  },{
    "title": "Intern Website",
    "date": "",
    "description": "實習成果展示網頁",
    "body": "升上大四就是不斷的忙來忙去，就連更新部落格的時間也沒有。這次就來久違的更新一下，雖然是之前的作品～～\n此作品為學校規定要做的展示網頁，當初也是花了我不少時間～我其實是把線上課程老師教的東西拿來改，雖然算是偷吃步，不過也是修改了不少東西，並且加上新樣式。做這個網頁我用了平常不會用的元素，有些甚至是為了達到效果，而去網路上爬文爬出來的，例如視差效果、滾動監測，還有最讓我花費時間的串google地圖的API。\n一般來說我們需要嵌入地圖時，直接一個embed就可以了，但是為了美化地圖樣式，我們必須去串接google地圖的API，我因此還被刷卡扣款了呢嗚嗚嗚，有關使用串接google地圖的API我之後會再做教學的，各位就先來欣賞我的網站吧！\n  intern  附上網站連結\n",
    "ref": "/portfolio/intern/"
  },{
    "title": "[教學]Flexbox",
    "date": "",
    "description": "Flexbox就只是叫小朋友排好隊形而已",
    "body": "前言 前端在切版時最最需要的就是排版，上篇文章就有偷偷使用display: flex來做排版，這次就讓我們來看看Flex到底有多麽強大！在了解Flex之前，我們需要知道它究竟是如何排版的。\n 以中央伍為準～～成體操隊形～～散開！\n 聽到這句口令，想必大家腦中已經浮現出排隊的隊形了吧！沒錯，這就是Flex的排版原理。想要叫人員乖乖排好就需要先限制場地，因此人員就只能在這個範圍活動，不會跑到外面去。而這個場地就是「外容器、Container、父元素」；而人員就是「內元件、items、子元素」，接下來大家就可以開始排排站好囉～～\n  Container,Items  ＊接下來我會以「Container」、「Items」來說明他們的關係\n首先來看看Container、Items各自有哪些屬性：\n Container：\n Display Flex-direction Flex-wrap Flex-flow Justify-content Align-items Align-content  Items：\n Order Flex-basis Flex-grow Flex-shrink Align-self   Container Flex主要都是在Container上下指令。\n 發動場地魔法卡「大地力量」，場面上地屬性怪獸的攻擊力可以上升500\u0026hellip;\n 沒錯，可以把它想像成場地效果，你要裡面的東西怎樣他就會怎樣，這樣就可以很好的控制裡面的內容了。以下介紹的屬性都是放在Container裡面的喔。\nDisplay 首先先宣告為flex它才能使用。\n\u0026lt;!-- css --\u0026gt; .container{ display: flex; } Flex-direction   flex-direction  Flex-direction負責管理Items該如何排列，它掌控著誰可以拿到主導權，能拿到主導權的有兩位人選，一位是column，另一位是row，也就是我們常講的「直行橫列」，直行是column；橫列是row。\n所謂的主導權就是「主軸（main-axis）」，既然有主軸那就有「副軸（cross-axis）」。預設下主軸為row，而副軸為column。主副軸彼此的關係為「十字交叉」，若一方為主軸，則另一方就是副軸，但Flex-direction只有決定主軸是誰，副軸的功用等等再說吧。我們現來看Flex-direction，它有4個語法，分別是：\n\u0026lt;!-- css --\u0026gt; flex-direction: row; /*預設，主軸由左至右*/ flex-direction: row-reverse; /*主軸由右至左*/ flex-direction: column; /*主軸由上至下*/ flex-direction: column-reverse; /*主軸由下至上*/   ＊因為瀏覽器對於每個語法的定義不同，因此在Chome上看到的flex-direction: column、flex-direction: column-reverse是會爆出框框的；而在Safari上看到的是塞好塞滿。不過兩者皆是把物件塞在同一排，即便有定義好Items的寬高，但在空間不夠時是會壓縮它們的喔！\n 咦咦咦！？我不要裡面的東西變形啦！！該怎麼解決呢？有兩個方法，第一個是減少Items，這樣空間就留出來了；第二個是加大Container的寬高。\n 但～～上面講的都治標不治本，接下來就來介紹解決方案吧！\nFlex-wrap   flex-direction  Flex-wrap決定了Items的排列方式，有別於前者說提到的Flex-direction，它控制物件該不該「包起來」。我們知道單就下Flex-direction只會讓items排一排站好，而且還有可能擠在一起，讓Items變形，因此Flex-wrap透過包起來的方式，將塞不下的Items換行繼續塞，而換行的方向就是根據副軸去排的喔。說了這麼多我們直接看看它到底有哪些功能：\n\u0026lt;!-- css --\u0026gt; flex-wrap: nowrap; /*預設，單行排列，不包起來*/ flex-wrap: wrap; /*包好包滿*/ flex-wrap: wrap-reverse; /*包好包滿外還要來個反轉*/   ＊Codepen展示中用到Flex-direction: row，其餘的排列組合就請自己去玩玩探索吧！\n＊Flex-wrap: reverse，反轉的地方是指「副軸反轉」，正常的方向是由左至右，由上至下，而反轉後的方向則變成了由右至左，由下至上\nFlex-flow 那麼這個屬性又是幹嘛的呢？？其實你也可以不用懂它，它就是Flex-direction、Flex-wrap的「組合技」，如此一來就可以共同定義主副軸的排列方式了。\n\u0026lt;!-- css --\u0026gt; flex-flow: flex-direction flex-wrap; /*大括號裡面放的就是它們各自的屬性*/ ＊預設為flex-flow: row nowrap\n接下來就進入重頭戲，也就是介紹Flex屬性是如何「排版」的吧！\nJustify-content   justify-content  Justify-content定義了「主軸」的「對齊方式」，有以下5種方式：\n\u0026lt;!-- css --\u0026gt; justify-content: flex-start; /*預設，靠頭對齊*/ justify-content: flex-end; /*靠尾對齊*/ justify-content: center; /*置中對齊*/ justify-content: space-between; /*置中對齊，頭尾的items貼齊Container，items之間有固定距離*/ justify-content: space-around; /*置中對齊，頭尾的items沒有貼齊Container，items之間、頭尾items跟Container之間皆有固定距離*/ justify-content: space-evenly; /*置中對齊，頭尾的items沒有貼齊Container，items之間、頭尾items跟Container之間距離相同*/   ＊Codepen展示中用到Flex-flow: row wrap，其餘的排列組合就請自己去玩玩探索吧！\n＊Justify-content是「控制主軸」，不是「控制左右」。在Flex-direction的控制下是有可能把主軸變為直向，副軸變為橫向。因此註解上我不以「靠左對齊」、「靠右對齊」而改用頭尾，原因是彼此的關係是互相的\n＊Justify-content:space-arounnd與Justify-content:space-evenly意思其實不太一樣喔。舉例來說每個items距離20px，那麼前者代表每個items都有20px，彼此的距離是40px；反觀後者，是每個items彼此之間的距離是20px\nAlign-items   align-items  Align-items定義了「副軸」的「對其方式」，有以下5種方式：\n\u0026lt;!-- css --\u0026gt; align-items: flex-start; /*預設，靠頭對齊*/ align-items: flex-end; /*靠尾對齊*/ align-items: center; /*置中對齊*/ align-items: baseline; /*按照文本基線對齊*/ align-items: stretch; /*items延展至Container的頭尾*/   ＊Codepen展示中用到Flex-flow: row wrap、Justify-content: center，其餘的排列組合就請自己去玩玩探索吧！\n＊使用stretch時，請不要設死Items的高度喔，不然它會拉不開\nAlign-content   align-content  這個屬性是Align-items的進階版，而且它跟Justify-content長得有八成像，所以他們能控制的東西也是一樣差不多～這裡再再提醒一次：Justify-content控制主軸；Align-content控制副軸喔。\n\u0026lt;!-- css --\u0026gt; align-content: flex-start; /*預設，靠頭對齊*/ align-content: flex-end; /*靠尾對齊*/ align-content: center; /*置中對齊*/ align-content: space-between; /*置中對齊，頭尾的items貼齊Container，items之間有固定距離*/ align-content: space-around; /*置中對齊，頭尾的items沒有貼齊Container，items之間、頭尾items跟Container之間皆有固定距離*/ align-content: stretch; /*items延展至Container的頭尾*/   ＊Codepen展示中用到Flex-flow: row wrap、Justify-content: center，其餘的排列組合就請自己去玩玩探索吧！\n＊使用stretch時，請不要設死Items的高度喔，不然它會拉不開\n以上大致講完Container可以用的屬性了，那麼我們就，下面一位～～～～\nItems Items也是有很多東西可以控制的，它能做到的事情主要是items跟items之間的關係，像是誰在前誰在後的order，又或是誰位置可以比較大誰位置可以比較小的Flex-grow跟Flex-shrink等等。有些屬性甚至能覆蓋掉Container的屬性呢，那就讓我們繼續看下去。\nOrder   order  order屬性可以控制誰在前誰在後，即使在HTML上的物件是在最後一個，只要下達這個指令就可以輕輕鬆鬆要它在哪它就在哪囉。\n\u0026lt;!-- css --\u0026gt; order: integer; /*預設為0，integer的地方是給整數*/   ＊Codepen展示中用到Flex-flow: row wrap、Justify-content: center、Align-content: space-around，其餘的排列組合就請自己去玩玩探索吧！\n＊order預設為零，若要排在0前面的話也可以負值喔\nFlex-basis 它決定了主軸上items的預設長度。以row當主軸來說它控制items的「寬度」；以column當主軸來說它控制items的「高度」\n\u0026lt;!-- css --\u0026gt; flex-basis: auto; /*預設為auto，可以給長度各種單位*/   ＊範例當中Flex-basis的長度為50px。以row來當主軸的話所有items的「寬度」皆為50px；反之以column當主軸的話所有items的「高度」皆為50px\nFlex-grow   flex-grow  這個屬性跟等一下講的屬性是相關的，可以將他們視為兄弟。Flex-grow屬性決定items如何分配剩餘空間。我們上範例會比較好理解：\n 第一個範例當中有三個items排在一起，彼此大小皆為100x100px。第二個範例只是都讓他們有flex-grow: 1的屬性，items就將Container撐好撐滿。\nflex-grow的預設值為0，也可以給其他的值，這個值代表要將剩下的空間分成幾等分。以這題為例，Container：600x350px；box：100x100px，那麼剩餘的空間就是600-(100*3)=300，因此就要來瓜分剩餘的300。items有三個，每個都有flex-grow: 1，因此切為三等份，每等分的長度則為300/3=100，所以每個items都會獲得100px的長度。\n那我們試著想一下，假設box1的flex-grow: 2，box2的flex-grow: 3那會變成怎麼樣呢？\n剩餘空間300要分給5等分，每等分為60，其中box1占2等分所以是120，而box2占3等分所以是180。最終items的長度分別為：220px、280px、100px（若把codepen上的範例改成這題，他們的實際大小可能會有一點點的落差，因為items都有border，border的長度也是會被算在裡面的。）\nFlex-shrink 剛剛的Flex-grow是處理當Container有剩餘空間時，將items「伸展」來符合Container的長度；現在Flex-shrink則是處理當Container不夠items塞時，將items「縮小」來符合Container的長度。\n 在第一個範例裡Container的大小是600x350px，每個items的長度皆為300px，照理來講items的長度比Container還要長，那為什麼它們沒有爆開呢？答案是在預設裡其實就已經加上了Flex-shrink:1了～因此它們都會被包在Container裡面。我們可以來算算實際上items到底多長，3個items總長度為3*300=900，扣掉Container的600，因此差為300。而各自的Flex-shrink皆為1，故300/3=100，每個items的長度都要減去100，所以長度為200。第二範例就只是把Flex-shrink設為0，items總長大於Container，那麼就會爆開了。\n再來看看第三個範例，長寬依舊，但是Flex-shrink分別是2、3、1，故300/(2+3+1)=50。box1占了2份，300-(2＊50)=200；box2占了3份，300-(3＊50)=150；box3占了1份，300-(1＊50)=250。這樣各位有清楚了嗎～\nAlign-self   align-self  終終終於來到最後一個屬性了啊！！！！（撒花～\n這個屬性可以調整「副軸」的對齊屬性，再重申一次，是「副軸」喔不是主軸。它與Align-items、Align-content一樣可以控制副軸的排列方式，它卻能更進一步個別調整單一item的排列方式，以下是它的語法：\n\u0026lt;!-- css --\u0026gt; align-self: auto; /*預設，與Container的align-items一樣*/ align-self: flex-start; /*預設，靠頭對齊*/ align-self: flex-end; /*靠尾對齊*/ align-self: center; /*置中對齊*/ align-self: baseline; /*按照文本基線對齊*/ align-self: stretch; /*items延展至Container的頭尾*/   ＊特別注意！Align-self給定的值是會壓過Align-items、Align-content的喔\n結語 其實Flex並沒有想象中的那麼難，我當初在學習時也是看到一大堆屬性就頭昏腦花了，但只要先了解Container與items各自是負責做什麼的，以及主軸和副軸之間的關係，其他的即便忘了，網路上找一下就知道該怎麼使用了。前端的路途是很遙遠的，我們共勉之～\n 參考資料：\n圖解：CSS Flex 屬性一點也不難\nCSS | 所以我說那個版能不能好切一點？ - Flex 基本用法\n[css] 搞懂 flex-grow, flex-shirk 及 flex-basis 三種屬性\nCSS Flexbox\n圖片來源：\nA Complete Guide to Flexbox\n",
    "ref": "/blog/20200925_flexbox/"
  },{
    "title": "Fasure",
    "date": "",
    "description": "虛擬電商實作",
    "body": "這是我第一個電商網站，主要使用Bootstrap來切版。\n這網站算是我自學Bootstrap後所做出來的成果，當時我還不太懂Bootstrap是什麼，對於框架的概念不甚了解，於是我就上網自學。後來找到一本書專門介紹Bootstrap如何使用，於是我就跟著他的步驟，一點一點慢慢學習。\n 書名：讓響應式(RWD)網頁設計變簡單：Bootstrap開發速成\n作者：呂國泰\n 回到專案，當初在建置網頁時都是用Bootstrap，就連顏色配置這些也都是用Bootstrap內建顏色，因此版型看起來非常中規中矩，不過對於初學者來說這應該算及格了吧？\n但也多虧這個專案讓我能夠更加深入了解Bootstrap的用法，如grid system、card、collapsed等，這些東西需要經過反覆實作才能夠熟悉，不然很快就會忘記了。此外我也有用一些套件來讓版面看起來不這麼單調，如fontawesome的icon、AOS.js的下滑動畫等，這讓我之後懂得使用套件，提升網頁的多變性。\n  fasure  附上網站連結\n",
    "ref": "/portfolio/fasure/"
  },{
    "title": "[教學]圖片自適應外框大小",
    "date": "",
    "description": "台灣公益資訊中心改版實作心得",
    "body": "前言 暑假一眨眼就過去了，回顧過去這兩個月來我也學到不少東西。七月主要改版台灣公益資訊中心的頁面，將網站改成RWD頁面並且新增一些功能。由於專案還在開發階段，因此無法公開頁面內容，請以舊版的台灣公益資訊中心做為參考。\n接下來的分享主要以我在開發時遇到的困難、學習到的新東西為主。那我們就開始吧！\n圖片自適應外框大小 標題取為「圖片自適應外框大小」我想一定有很多人看不懂這到底是什麼意思。簡單來說，會使用本平台的人數百百種，當他們在上架內容時若剛好有圖片，就會有以下情況：\n 點擊上傳圖片 \u0026gt; 隨便丟一張覺得拍得不錯的照片 \u0026gt; 送出\n 剛剛的順序看似再正常不過了，不過使用者有想過隨邊丟一張圖片這確定沒問題嗎？？\n撇除照片檔案太大會影響載入速度外，另一個問題就是「照片的寬高比例」。現代人拍照通常都用手機，但是各家手機尺寸都不盡相同，若將未經裁切的照片丟上網頁，那一定會跑版\u0026hellip;\n解法一：max-width: 100%, max-height: 100% 為了解決這個問題，我原本的想法是在圖片的外層包一層div，並且控制外層大小及照片的排列方式。若照片比例與外框比例不符，它就會等比例縮在外框裡。\n\u0026lt;!-- html --\u0026gt; \u0026lt;div class=\u0026#34;pic\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://images.unsplash.com/photo-1600068643981-3c4496a2be55?ixlib=rb-1.2.1\u0026amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9\u0026amp;amp;auto=format\u0026amp;amp;fit=crop\u0026amp;amp;w=2467\u0026amp;amp;q=80\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pic\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://images.unsplash.com/photo-1599930499224-1b9a45439a12?ixlib=rb-1.2.1\u0026amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9\u0026amp;amp;auto=format\u0026amp;amp;fit=crop\u0026amp;amp;w=1164\u0026amp;amp;q=80\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; ＊圖片的src=\u0026quot;...\u0026quot;是在圖片地址，你可以換張圖片試試\n/* css */ html, body { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-wrap: wrap; background-color: #3d3d3d; } .pic { width: 500px; height: 350px; margin: 50px; display: flex; justify-content: center; align-items: center; border: 2px solid; } .pic img { max-width: 100%; max-height: 100%; } ＊html、body是為了排版用\n＊主要看.pic跟.pic img那邊，外層先固定好大小，並使用flex排版，讓裡面的內容能夠水平置中及垂直置中；內層的圖片分別在最大寬度、最大高度指定為100%，意思為寬高最大就是100%，若圖片的寬度大於高度，則寬度就是100%，而高度就依照比例去計算，反之亦然\n 解法二：object-fit 後來發現另一個更厲害的css內建語法，他叫做object-fit，若要以我剛剛的範例來說，它的語法就是object-fit: contain。\n\u0026lt;!-- html --\u0026gt; \u0026lt;div class=\u0026#34;pic\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://images.unsplash.com/photo-1600068643981-3c4496a2be55?ixlib=rb-1.2.1\u0026amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9\u0026amp;amp;auto=format\u0026amp;amp;fit=crop\u0026amp;amp;w=2467\u0026amp;amp;q=80\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pic\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://images.unsplash.com/photo-1599930499224-1b9a45439a12?ixlib=rb-1.2.1\u0026amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9\u0026amp;amp;auto=format\u0026amp;amp;fit=crop\u0026amp;amp;w=1164\u0026amp;amp;q=80\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; /* css */ html, body { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-wrap: wrap; background-color: #3d3d3d; } .pic { width: 500px; height: 350px; margin: 50px; border: 2px solid; } .pic img { object-fit: contain; width: 500px; height: 350px; } ＊使用object-fit就只要在圖片上加上語法，並且列出想要的寬高就可以了\n 眼尖的人可能會發現，它的語法大致跟background-size一樣，所以它同樣有好幾種顯示方式：\n fill：為預設值，強制讓圖片變形成外框的寬高。（很醜誒哈哈哈哈 contain：按照圖片等比例縮放塞入外框內。 cover：填滿外框，超出外框的部分會被裁切掉。 none：不做任何調整。（請問我要用你幹嘛？？ scale-down：取決於圖片與外框的大小。若外框小於圖片就用contain；若外框大於圖片就用none。  另外他還有個好朋友叫做object-position，可以理解為圖片在外框中的擺放位置，預設是在正中間。他們兩個可以互相搭配使用，說不定能擦出什麼火花（？？\n  object-fit、object-position瀏覽器支援程度  BTW，剛剛講的object-fit、object-position並不支援IE喔，不過現在應該很少人在用IE了吧！\n結語 其實還有很多種方式可以達成圖片自適應外框大小，若你有新的作法與想法，歡迎在下方留言喔！\n",
    "ref": "/blog/20200914/"
  },{
    "title": "About",
    "date": "",
    "description": "自我介紹內容～",
    "body": "你好，我是米米，是個剛畢業就已經成為社畜的前端工程師==\n因緣際會下接觸到前端工程，因此開始了我的前端人生。在這裡我會分享我的所見所聞，主要以工作上學習到的心得為主。還有偶爾發發廢文（？\n",
    "ref": "/about/"
  }]
