[{
    "title": "[軟體分享]在touch bar上顯示歌詞！",
    "date": "",
    "description": "Show Lyrics on Touch Bar",
    "body": "前言 大家好，最近忙的事情差不多都告一段落了，就來分享兩個讓touch bar能夠顯示歌詞的軟體吧！兩者各有各的優缺點，安裝方式也不一樣，就讓我們繼續看下去吧！\n 目錄：\n LyricsX touchbar_lyric   LyricsX 這個軟體能在App store上找到，它是一套能夠支援iTunes、Spotify、Vox、Audirvana、Swinsian等串流軟體，自動搜尋相對應的歌詞，並且可以設定歌詞要提前或延後顯示，還可將簡體中文自動翻譯成繁體中文，功能非常豐富。LyricsX提供多種呈現方式，但本次僅介紹如何將它應用在touch bar上。\n在App store上的LyricsX是閹割版的，並不支持touch bar歌詞功能，必須從LyricsX的Github上下載。\n附上網站連結\n  下載最新版本的zip檔  下載LyricsX的壓縮包，並且點開執行。此時會跳出一個警告視窗，提醒說是否要打開。\n  授權打開LyricsX  若打不開，請去系統偏好設定裡強制打開。點擊「蘋果鍵 \u0026gt; 系統偏好設定⋯ \u0026gt; 安全性與隱私權 \u0026gt; 一般」，按下強制打開就可以了。\n＊貼心小提醒：因為軟體不是從App store上載下來的，所以他的位置是在「下載項目」，記得把他拖曳到「應用程式」喔！\n基本上就安裝完成了。如果你剛好在播放音樂，那麼歌詞就已經出現在桌面上囉！接著我們要把歌詞塞在touch bar裡。\n  歌詞會顯示在桌面上  點選上方選單列LyricsX的icon，並且選擇偏好設定。\n＊貼心小提醒：在這裡可以把「啟用動態歌詞」關閉，畢竟一直出現在視窗上有點煩人\n  關閉桌面歌詞並且進入偏好設定  裡面有很多東西可以設定，像是偏好的音樂播放器、雙語歌詞、轉為繁中等等，各位可以依照自己的使用情境來設定。\n接著進入「實驗功能」必且把「啟用Touch Bar歌詞」打開，如此一來就可以在touch bar上顯示歌詞了。\n  啟用touch bar歌詞  此時的touch bar會出現LyricsX的icon，點擊它之後歌詞就會跑出來了。\n  點選icon    歌詞出現！  touchbar_lyric 這個軟體是需要搭配BetterTouchTool來使用的。簡單來說BetterTouchTool可以完全客製化touch bar的內容，多了很多彈性，當然設定也就蠻複雜的，網路上有很多別人做好的設定，下載下來並且根據自己需要的情境做設定是最快的方法。，由於設定BetterTouchTool需要花很長的篇幅來講解，這裡僅分享如何安裝歌詞的外掛到BetterTouchTool上，BetterTouchTool的安裝設定就不多贅述了，說不定哪天我心情好就來寫～\n此次的安裝需要打一些程式碼，稍微有些難度，但我們會一步一步慢慢來。\n我們使用homebrew來安裝python3，之後再去安裝touchbar_lyric。將此段程式碼貼到終端機上。\n/bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot; 安裝好homebrew之後，接著來安裝python3。一樣將下列程式碼貼到終端機上。\nbrew install python3 在終端機輸入下列程式碼：\npip3 install touchbar_lyric --upgrade 安裝完成之後，複製以下文字，之後直接貼在BetterTouchTool。\n[ { \u0026quot;BTTWidgetName\u0026quot; : \u0026quot;Lyric\u0026quot;, \u0026quot;BTTTriggerType\u0026quot; : 642, \u0026quot;BTTTriggerTypeDescription\u0026quot; : \u0026quot;Shell Script \\/ Task Widget\u0026quot;, \u0026quot;BTTTriggerClass\u0026quot; : \u0026quot;BTTTriggerTypeTouchBar\u0026quot;, \u0026quot;BTTPredefinedActionType\u0026quot; : -1, \u0026quot;BTTPredefinedActionName\u0026quot; : \u0026quot;No Action\u0026quot;, \u0026quot;BTTShellScriptWidgetGestureConfig\u0026quot; : \u0026quot;\\/bin\\/sh:::-c:::-:::\u0026quot;, \u0026quot;BTTEnabled2\u0026quot; : 1, \u0026quot;BTTRepeatDelay\u0026quot; : 0, \u0026quot;BTTUUID\u0026quot; : \u0026quot;93C8B565-73C7-49BE-960A-4FCF512CE881\u0026quot;, \u0026quot;BTTNotesInsteadOfDescription\u0026quot; : 0, \u0026quot;BTTEnabled\u0026quot; : 1, \u0026quot;BTTModifierMode\u0026quot; : 0, \u0026quot;BTTOrder\u0026quot; : 0, \u0026quot;BTTDisplayOrder\u0026quot; : 99, \u0026quot;BTTMergeIntoTouchBarGroups\u0026quot; : 0, \u0026quot;BTTTriggerConfig\u0026quot; : { \u0026quot;BTTTouchBarFreeSpaceAfterButton\u0026quot; : 0, \u0026quot;BTTTouchBarOnlyShowIcon\u0026quot; : false, \u0026quot;BTTTouchBarButtonColor\u0026quot; : \u0026quot;0.000000, 0.000000, 0.000000, 255.000000\u0026quot;, \u0026quot;BTTTouchBarApplyCornerRadiusTo\u0026quot; : 0, \u0026quot;BTTTouchBarItemPlacement\u0026quot; : 0, \u0026quot;BTTTouchBarAppleScriptStringRunOnInit\u0026quot; : true, \u0026quot;BTTTouchBarAlwaysShowButton\u0026quot; : false, \u0026quot;BTTTouchBarFontColorAlternate\u0026quot; : \u0026quot;0.000000, 0.000000, 0.000000, 255.000000\u0026quot;, \u0026quot;BTTScriptType\u0026quot; : 0, \u0026quot;BTTTouchBarButtonWidth\u0026quot; : 550, \u0026quot;BTTTouchBarScriptUpdateInterval\u0026quot; : 1, \u0026quot;BTTTouchBarItemIconHeight\u0026quot; : 22, \u0026quot;BTTTouchBarButtonUseFixedWidth\u0026quot; : 0, \u0026quot;BTTTouchBarButtonTextAlignment\u0026quot; : 1, \u0026quot;BTTTouchBarAlternateBackgroundColor\u0026quot; : \u0026quot;0.000000, 0.000000, 0.000000, 255.000000\u0026quot;, \u0026quot;BTTTBWidgetWidth\u0026quot; : 400, \u0026quot;BTTTouchBarItemIconWidth\u0026quot; : 22, \u0026quot;BTTTouchBarShellScriptString\u0026quot; : \u0026quot;$PYTHONPATH -m touchbar_lyric --app Spotify\u0026quot;, \u0026quot;BTTTouchBarIconTextOffset\u0026quot; : 5, \u0026quot;BTTTouchBarButtonFontSize\u0026quot; : 12, \u0026quot;BTTTouchBarFontColor\u0026quot; : \u0026quot;156.000006, 226.000002, 90.000002, 255.000000\u0026quot;, \u0026quot;BTTTouchBarButtonName\u0026quot; : \u0026quot;Lyric\u0026quot;, \u0026quot;BTTTouchBarButtonCornerRadius\u0026quot; : 6, \u0026quot;BTTTouchBarItemPadding\u0026quot; : 20 } } ] 接著在Script裡面填上：\n/usr/local/Cellar/python@3.9/3.9.4/bin/python3.9 -m touchbar_lyric --app Music --traditional    script設定  這裡講解一下程式碼。\n 剛剛用homebrew下載的python會放在Cellar的資料夾裡，每個人下載的版本可能會略微不同，但道理是一樣的，選擇python的路徑就對了。 這裡偵測Apple Music播放器，若使用Spotify當作主要的播放器，將程式碼的「Music」代換成「Spotify」就可以了。 最後的「traditional」是將簡體中文轉換成繁體中文。  到這裡基本的設定就設定完成了，若要更改文字顏色、文字大小及背景顏色等等可以在「Common」裡面設定。\n  設定文字大小、顏色、背景色  結語 LyricsX跟touchbar_lyric兩者我都有使用，不過後都用後者居多，畢竟我有在用BetterTouchTool嘛～這兩者我用過，以下是我的心得感想。\nLyricsX的優點：\n 方便安裝，操作簡易 有多種控制選項 可以控制歌詞提早、延後出現的時間  LyricsX的可改進的有：\n 自動轉成繁體中文的功能常常失靈  touchbar_lyric的優點：\n 可搭配BetterTouchTool使用 歌詞支持繁體中文  touchbar_lyric可改進的有：\n 安裝過程麻煩 歌詞有時候會出錯 歌詞出現時間過晚 可偵測的播放來源過少  以上就是這次的分享，若有問題也可以在底下留言互相討論喔！\n 參考資料：\nLyricsX\ntouchbar-lyric\n",
    "ref": "/blog/20210426_touchbar_lyrics/"
  },{
    "title": "台灣公益資訊中心",
    "date": "",
    "description": "Taiwan NPO Information Platform",
    "body": "新版的台灣公益資訊中心已經上線了一段時間了，在這裡先介紹這個網站的功用，它是台灣最大的公益社群入口，免費提供非營利組織發佈公益新聞、活動以及人才招募等等，新版也加入了義賣平台、補助公告等等新內容，目的在於加強公益團體的資訊流通及行銷，縮減公益團體的數位落差，提升非營利組織的曝光。\n這個專案可以說是我的處女作，第一次寫網頁就接手這麼大的專案，那時的壓力真的蠻大的\u0026hellip;\u0026hellip;.現在回頭來看看就覺得蠻有成就感的了。「在什麼都還不熟的情況下接手專案能讓人快速進步」這是我做完這個專案後得到的心得，儘管還有很多地方不足的，但凡走過必留下痕跡，未來再有類似狀況也知道要朝哪個方向修正。\n  Taiwan NPO Information Platform  附上網站連結\n",
    "ref": "/portfolio/npo/"
  },{
    "title": "[教學]Grid",
    "date": "",
    "description": "可以二維排列的Grid",
    "body": "前言 grid是一個很好用的排版工具之一，他甚至比flex好用呢！兩者之間有相似也有不相似的地方，就讓我們繼續看下去吧！\ngrid的包法與flex一樣，需要有外層的.container，也需要有內層的.items，若不懂內外層之間的關係，可以去看看我之前寫的[教學]FLEXBOX。\n照慣例，先來看看Container、Items的屬性有哪些：\n Container：\n Display Grid-template-columns_rows Grid-template-areas Grid-gap Justify-items Align-items  Items：\n Grid-column_row Justify-self Align-self   Container 跟flex一樣，grid大都是在container裡面下指令。\nDisplay 先宣告要使用grid來排版。\n\u0026lt;!-- css --\u0026gt; .container{ display: grid; } grid不像flex一下display就會有變化，它還需要把空間切成一塊一塊的才能使用，雖說有些麻煩，但事後在定位排版上會比較好操作，靈活度也比flex還要來得高。\nGrid-template-columns_rows Template的意思為模板，我們透過這個屬性把想要的區塊切開。它的語法主要分兩個：\n\u0026lt;!-- css --\u0026gt; grid-template-columns: 100px 50px auto 200px 1fr; \u0026lt;!-- 直行 --\u0026gt; grid-template-rows: 25% 100px 1fr; \u0026lt;!-- 橫列 --\u0026gt;   ＊給定的值可以使用px、%、fr等長度單位\n我們從左至右看，可以發現每一格的寬度是「100px 50px auto 200px 1fr」，這不就跟css內的grid-template-column一樣嗎！它的意思是「切幾格，每格自己給定」，以剛剛的例子來說就是切五格，每格的長度按照裡面的值所定。同理grid-template-rows也是如此。\nGrid-template-areas 這東西像是給定切好的區塊一個名字，之後在items叫它去該區塊。在Container裡先設好模版該長什麼樣、該叫什麼名字，每個格子裡要放哪個items。\n\u0026lt;!-- css --\u0026gt; .container{ grid-template-areas: \u0026#34;header header header header\u0026#34; \u0026#34;main main . sidebar\u0026#34; \u0026#34;footer footer footer footer\u0026#34;; } .item1{ grid-area: header; } .item2{ grid-area: main; } .item3{ grid-area: sidebar; } .item4{ grid-area: footer; } 上面的例子就是把Container切成4欄，第一列統一都是header；第二列main佔2欄，之後的為空白，最後一欄是sidebar；第三列皆為footer。而Items就分別帶入各自的名字。\n ＊空白的地方以\u0026quot;.\u0026ldquo;代替\nGrid-gap 這個功能類似上次提到flex的gap，若不知道在講什麼的朋友可以先來看看[教學]GAP再來了解。\ngrid-gap好用的地方在於它的彈性更多，safari也能夠讀取。它有三種寫法，column-gap及row-gap分別控制行、列之間的間隙，而grid-gap是兩個我都要！一次控制行列的間隙。\n\u0026lt;!-- css --\u0026gt; column-gap: 10px; \u0026lt;!-- column之間的間隙為10px --\u0026gt; row-gap: 15px; \u0026lt;!-- row之間的間隙為15px --\u0026gt; grid-gap: 20px; \u0026lt;!-- 所有格子之間的間隙為20px --\u0026gt; 值得注意的是，這裡給定的值是會影響整個寬度的喔！舉例來說，grid-template-column: 50% 50%，如果我們加上column-gap: 50px，那麼寬度是會炸開的，因為他們的總和超過100%了。\n所以我通常使用fr的單位，變成grid-template-colum: 1fr 1fr就不會有這個問題了。fr的概念可以想像成「將剩餘的空間按照比例去分配」，以grid-template-colum: 1fr 1fr為例，1+1=2，所以每一份間隔皆為1/2。\n那麼依樣畫葫蘆，grid-template-colum: 1fr 2fr 3fr每一欄的寬度分別為1/6，2/6，3/6，是不是蠻簡單的～\nJustify-items   justify-items  此功能與flex的justify-content類似，同樣是控制items水平靠左、置中、靠右。grid不用控制主軸與次軸，因此justify-content就是控制「水平」方向的排版。\n\u0026lt;!-- css --\u0026gt; justify-items: start; \u0026lt;!-- 靠左 --\u0026gt; justify-items: end; \u0026lt;!-- 靠右 --\u0026gt; justify-items: center; \u0026lt;!-- 置中 --\u0026gt; justify-items: stretch; \u0026lt;!-- 伸展 --\u0026gt;   ＊使用stretch時，不可控制裡面的大小，不然會調不動\nAlign-items   align-items  這個功能就跟flex的align-items一模模一樣樣～直接輕鬆套用！\n\u0026lt;!-- css --\u0026gt; align-items: start; \u0026lt;!-- 靠上 --\u0026gt; align-items: end; \u0026lt;!-- 靠底 --\u0026gt; align-items: center; \u0026lt;!-- 置中 --\u0026gt; align-items: stretch; \u0026lt;!-- 伸展 --\u0026gt;   ＊使用stretch時，不可控制裡面的大小，不然會調不動\n到這裡其實可以發現grid的排版方式其實比flex簡單很多，flex光是方向在那邊換來換去就已經搞死不少人了，而grid一次控制好兩邊，功能可以做到很複雜但依然好懂！\ncontainer的功能就先到這裡告一段落了，雖然還有其他的功能，但我覺得不常用，因此就沒放上來了（其實就是懶得寫啦哈哈哈哈\nGrid-column_row grid將container切成網格狀，再把items一個一個塞入每格的格子裡，若想把其中的一個items塞入好幾格格子，我們可以使用grid-template-areas來命名格子的名稱，再把items一次塞進去。這裡有個更好用的方法就是使用grid-colum以及grid-row。\n我們使用grid-colum以及grid-row來刻出上面grid-template-areas的版面吧！\n 範例當中我們把每列切成4欄。header需要把第一列佔滿，因此為grid-colum: 1/5，我們把每列切成4塊，所以會有5條線，也就是範例當中的黃線，由左至右分別為1~5，那麼1/5的意思就是從第1條線到第5條線。\n再來看看sidebar，它需要在最右邊，假設沒有控制他的話它就會接著前面的格子繼續排下去。因此它的grid-colum為4/5。\n此範例僅使用grid-colum而已，若和grid-row搭配可以產生出更多樣的排版方式。\nJustify-self   justify-self  justify-self是控制item自己的水平排版，這可是flex所沒有的屬性，flex根本不給排啊～\n\u0026lt;!-- css --\u0026gt; justify-self: start; \u0026lt;!-- 靠左 --\u0026gt; justify-self: end; \u0026lt;!-- 靠右 --\u0026gt; justify-self: center; \u0026lt;!-- 置中 --\u0026gt; justify-self: stretch; \u0026lt;!-- 延伸 --\u0026gt;   ＊此範例container使用水平、垂直置中，justify-self下的指令會壓過外層container\nAlign-self   align-self  來到最後一個屬性：align-self，是控制item自己的垂直排版，這屬性flex倒是有的，用法其實也一模一樣～\n\u0026lt;!-- css --\u0026gt; align-self: start; \u0026lt;!-- 靠上 --\u0026gt; align-self: end; \u0026lt;!-- 靠底 --\u0026gt; align-self: center; \u0026lt;!-- 置中 --\u0026gt; align-self: stretch; \u0026lt;!-- 伸展 --\u0026gt;   ＊此範例container使用水平、垂直置中，align-self下的指令會壓過外層container\n結語 grid的用法很多變，每次有版面切不出來時我通常都會用grid來切，如果切不出來的話\u0026hellip;那就把grid、flex混搭一起用，效果更好！\nBTW，最近真的有夠忙的，近期應該不會再更新這種教學了，要花費豪多時間呢！之後應該會更新一些小教學，至於是什麼呢～我也不知道，因為根本還沒想哈哈哈，就這樣了，ㄅㄅ～\n 參考資料：\nA Complete Guide to Grid\n",
    "ref": "/blog/20210205_grid/"
  },{
    "title": "[教學]Gap",
    "date": "",
    "description": "Gap:「請做好社交距離」",
    "body": "前言 在上一篇文章中講解了如何用flex排版，如果還沒看過的話請去看[教學]FLEXBOX再來看這篇文章喔。\n各位在使用Flex時有沒有發生過Container裡面的items都會黏在一起、擠在一起的情況呢？這時我想大家的處理方式應該都是在items下外距來隔開吧！這次要介紹的就是超級方便的gap，他可以快速控制的items的之間的間隔喔！\nGAP 它使用的方式非常簡單，只要在Container裡加上：\n\u0026lt;!-- css --\u0026gt; .container{ gap: 20px; } 好，結束收工。\n484很～～～～～～簡單。\n 但是\u0026hellip;我用safari看完全沒有間隔R，東西還是黏在一起誒。為什麼會這樣子？\n 我們可以去查一下gap語法的支援程度如何。\n  gap的支援程度  恩\u0026hellip;滿江紅一片呢，這代表還有很多瀏覽器不支援，各位請加油好嗎？\n在各瀏覽器普遍還沒支援的情況下，我們可以換一種寫法，讓沒有不支援的瀏覽器也能呈現出gap的樣式。\n修改後的GAP 為了達到目的，我們必須從Container跟items下手。\n\u0026lt;!-- css --\u0026gt; .container{ display: flex; flex-wrap: wrap; --gap: 20px; margin: calc(-1 * var(--gap)) 0 0 calc(-1 * var(--gap)); } .container \u0026gt; *{ margin: var(--gap) 0 0 var(--gap); } ＊--gap這個東西css裡面的變數，我們將想要的間隔寬度存在這裡，之後要改大小就只需在這裡處理就好。\n它的原理很簡單，以items來說，彼此之間都要有距離，因此每個items都需要在「上方」及「左側」有外距，但如次一來在「上方第一橫排的items」跟「左側第一直排的items」就會跟Container產生間隔。\n這時就換Container來處理問題。我們只需把Container「上方」及「左側」的外距再縮回來就能達到這個效果了。\n ＊2021/06/04更新：現在Safari也已經支援使用gap了，上面的東西大家看看就好。\n結語 其實我比較希望各家瀏覽器能快快支援gap，但目前也只能先以修改外距來達到類似的效果。不過不用灰心，因為除了gap能控制間隔外，還有另一個也能控制間隔的語法，不過這並不在flex的範疇裡，而是在更方便的grid裡，之後會陸陸續續地放上來喔～\n",
    "ref": "/blog/20201120_gap/"
  },{
    "title": "Intern Website",
    "date": "",
    "description": "實習成果展示網頁",
    "body": "升上大四就是不斷的忙來忙去，就連更新部落格的時間也沒有。這次就來久違的更新一下，雖然是之前的作品～～\n此作品為學校規定要做的展示網頁，當初也是花了我不少時間～我其實是把線上課程老師教的東西拿來改，雖然算是偷吃步，不過也是修改了不少東西，並且加上新樣式。做這個網頁我用了平常不會用的元素，有些甚至是為了達到效果，而去網路上爬文爬出來的，例如視差效果、滾動監測，還有最讓我花費時間的串google地圖的API。\n一般來說我們需要嵌入地圖時，直接一個embed就可以了，但是為了美化地圖樣式，我們必須去串接google地圖的API，我因此還被刷卡扣款了呢嗚嗚嗚，有關使用串接google地圖的API我之後會再做教學的，各位就先來欣賞我的網站吧！\n  intern  附上網站連結\n",
    "ref": "/portfolio/intern/"
  },{
    "title": "[教學]Flexbox",
    "date": "",
    "description": "Flexbox就只是叫小朋友排好隊形而已",
    "body": "前言 前端在切版時最最需要的就是排版，上篇文章就有偷偷使用display: flex來做排版，這次就讓我們來看看Flex到底有多麽強大！在了解Flex之前，我們需要知道它究竟是如何排版的。\n 以中央伍為準～～成體操隊形～～散開！\n 聽到這句口令，想必大家腦中已經浮現出排隊的隊形了吧！沒錯，這就是Flex的排版原理。想要叫人員乖乖排好就需要先限制場地，因此人員就只能在這個範圍活動，不會跑到外面去。而這個場地就是「外容器、Container、父元素」；而人員就是「內元件、items、子元素」，接下來大家就可以開始排排站好囉～～\n  Container,Items  ＊接下來我會以「Container」、「Items」來說明他們的關係\n首先來看看Container、Items各自有哪些屬性：\n Container：\n Display Flex-direction Flex-wrap Flex-flow Justify-content Align-items Align-content  Items：\n Order Flex-basis Flex-grow Flex-shrink Align-self   Container Flex主要都是在Container上下指令。\n 發動場地魔法卡「大地力量」，場面上地屬性怪獸的攻擊力可以上升500\u0026hellip;\n 沒錯，可以把它想像成場地效果，你要裡面的東西怎樣他就會怎樣，這樣就可以很好的控制裡面的內容了。以下介紹的屬性都是放在Container裡面的喔。\nDisplay 首先先宣告為flex它才能使用。\n\u0026lt;!-- css --\u0026gt; .container{ display: flex; } Flex-direction   flex-direction  Flex-direction負責管理Items該如何排列，它掌控著誰可以拿到主導權，能拿到主導權的有兩位人選，一位是column，另一位是row，也就是我們常講的「直行橫列」，直行是column；橫列是row。\n所謂的主導權就是「主軸（main-axis）」，既然有主軸那就有「副軸（cross-axis）」。預設下主軸為row，而副軸為column。主副軸彼此的關係為「十字交叉」，若一方為主軸，則另一方就是副軸，但Flex-direction只有決定主軸是誰，副軸的功用等等再說吧。我們現來看Flex-direction，它有4個語法，分別是：\n\u0026lt;!-- css --\u0026gt; flex-direction: row; /*預設，主軸由左至右*/ flex-direction: row-reverse; /*主軸由右至左*/ flex-direction: column; /*主軸由上至下*/ flex-direction: column-reverse; /*主軸由下至上*/   ＊因為瀏覽器對於每個語法的定義不同，因此在Chome上看到的flex-direction: column、flex-direction: column-reverse是會爆出框框的；而在Safari上看到的是塞好塞滿。不過兩者皆是把物件塞在同一排，即便有定義好Items的寬高，但在空間不夠時是會壓縮它們的喔！\n 咦咦咦！？我不要裡面的東西變形啦！！該怎麼解決呢？有兩個方法，第一個是減少Items，這樣空間就留出來了；第二個是加大Container的寬高。\n 但～～上面講的都治標不治本，接下來就來介紹解決方案吧！\nFlex-wrap   flex-direction  Flex-wrap決定了Items的排列方式，有別於前者說提到的Flex-direction，它控制物件該不該「包起來」。我們知道單就下Flex-direction只會讓items排一排站好，而且還有可能擠在一起，讓Items變形，因此Flex-wrap透過包起來的方式，將塞不下的Items換行繼續塞，而換行的方向就是根據副軸去排的喔。說了這麼多我們直接看看它到底有哪些功能：\n\u0026lt;!-- css --\u0026gt; flex-wrap: nowrap; /*預設，單行排列，不包起來*/ flex-wrap: wrap; /*包好包滿*/ flex-wrap: wrap-reverse; /*包好包滿外還要來個反轉*/   ＊Codepen展示中用到Flex-direction: row，其餘的排列組合就請自己去玩玩探索吧！\n＊Flex-wrap: reverse，反轉的地方是指「副軸反轉」，正常的方向是由左至右，由上至下，而反轉後的方向則變成了由右至左，由下至上\nFlex-flow 那麼這個屬性又是幹嘛的呢？？其實你也可以不用懂它，它就是Flex-direction、Flex-wrap的「組合技」，如此一來就可以共同定義主副軸的排列方式了。\n\u0026lt;!-- css --\u0026gt; flex-flow: flex-direction flex-wrap; /*大括號裡面放的就是它們各自的屬性*/ ＊預設為flex-flow: row nowrap\n接下來就進入重頭戲，也就是介紹Flex屬性是如何「排版」的吧！\nJustify-content   justify-content  Justify-content定義了「主軸」的「對齊方式」，有以下5種方式：\n\u0026lt;!-- css --\u0026gt; justify-content: flex-start; /*預設，靠頭對齊*/ justify-content: flex-end; /*靠尾對齊*/ justify-content: center; /*置中對齊*/ justify-content: space-between; /*置中對齊，頭尾的items貼齊Container，items之間有固定距離*/ justify-content: space-around; /*置中對齊，頭尾的items沒有貼齊Container，items之間、頭尾items跟Container之間皆有固定距離*/ justify-content: space-evenly; /*置中對齊，頭尾的items沒有貼齊Container，items之間、頭尾items跟Container之間距離相同*/   ＊Codepen展示中用到Flex-flow: row wrap，其餘的排列組合就請自己去玩玩探索吧！\n＊Justify-content是「控制主軸」，不是「控制左右」。在Flex-direction的控制下是有可能把主軸變為直向，副軸變為橫向。因此註解上我不以「靠左對齊」、「靠右對齊」而改用頭尾，原因是彼此的關係是互相的\n＊Justify-content:space-arounnd與Justify-content:space-evenly意思其實不太一樣喔。舉例來說每個items距離20px，那麼前者代表每個items都有20px，彼此的距離是40px；反觀後者，是每個items彼此之間的距離是20px\nAlign-items   align-items  Align-items定義了「副軸」的「對其方式」，有以下5種方式：\n\u0026lt;!-- css --\u0026gt; align-items: flex-start; /*預設，靠頭對齊*/ align-items: flex-end; /*靠尾對齊*/ align-items: center; /*置中對齊*/ align-items: baseline; /*按照文本基線對齊*/ align-items: stretch; /*items延展至Container的頭尾*/   ＊Codepen展示中用到Flex-flow: row wrap、Justify-content: center，其餘的排列組合就請自己去玩玩探索吧！\n＊使用stretch時，請不要設死Items的高度喔，不然它會拉不開\nAlign-content   align-content  這個屬性是Align-items的進階版，而且它跟Justify-content長得有八成像，所以他們能控制的東西也是一樣差不多～這裡再再提醒一次：Justify-content控制主軸；Align-content控制副軸喔。\n\u0026lt;!-- css --\u0026gt; align-content: flex-start; /*預設，靠頭對齊*/ align-content: flex-end; /*靠尾對齊*/ align-content: center; /*置中對齊*/ align-content: space-between; /*置中對齊，頭尾的items貼齊Container，items之間有固定距離*/ align-content: space-around; /*置中對齊，頭尾的items沒有貼齊Container，items之間、頭尾items跟Container之間皆有固定距離*/ align-content: stretch; /*items延展至Container的頭尾*/   ＊Codepen展示中用到Flex-flow: row wrap、Justify-content: center，其餘的排列組合就請自己去玩玩探索吧！\n＊使用stretch時，請不要設死Items的高度喔，不然它會拉不開\n以上大致講完Container可以用的屬性了，那麼我們就，下面一位～～～～\nItems Items也是有很多東西可以控制的，它能做到的事情主要是items跟items之間的關係，像是誰在前誰在後的order，又或是誰位置可以比較大誰位置可以比較小的Flex-grow跟Flex-shrink等等。有些屬性甚至能覆蓋掉Container的屬性呢，那就讓我們繼續看下去。\nOrder   order  order屬性可以控制誰在前誰在後，即使在HTML上的物件是在最後一個，只要下達這個指令就可以輕輕鬆鬆要它在哪它就在哪囉。\n\u0026lt;!-- css --\u0026gt; order: integer; /*預設為0，integer的地方是給整數*/   ＊Codepen展示中用到Flex-flow: row wrap、Justify-content: center、Align-content: space-around，其餘的排列組合就請自己去玩玩探索吧！\n＊order預設為零，若要排在0前面的話也可以負值喔\nFlex-basis 它決定了主軸上items的預設長度。以row當主軸來說它控制items的「寬度」；以column當主軸來說它控制items的「高度」\n\u0026lt;!-- css --\u0026gt; flex-basis: auto; /*預設為auto，可以給長度各種單位*/   ＊範例當中Flex-basis的長度為50px。以row來當主軸的話所有items的「寬度」皆為50px；反之以column當主軸的話所有items的「高度」皆為50px\nFlex-grow   flex-grow  這個屬性跟等一下講的屬性是相關的，可以將他們視為兄弟。Flex-grow屬性決定items如何分配剩餘空間。我們上範例會比較好理解：\n 第一個範例當中有三個items排在一起，彼此大小皆為100x100px。第二個範例只是都讓他們有flex-grow: 1的屬性，items就將Container撐好撐滿。\nflex-grow的預設值為0，也可以給其他的值，這個值代表要將剩下的空間分成幾等分。以這題為例，Container：600x350px；box：100x100px，那麼剩餘的空間就是600-(100*3)=300，因此就要來瓜分剩餘的300。items有三個，每個都有flex-grow: 1，因此切為三等份，每等分的長度則為300/3=100，所以每個items都會獲得100px的長度。\n那我們試著想一下，假設box1的flex-grow: 2，box2的flex-grow: 3那會變成怎麼樣呢？\n剩餘空間300要分給5等分，每等分為60，其中box1占2等分所以是120，而box2占3等分所以是180。最終items的長度分別為：220px、280px、100px（若把codepen上的範例改成這題，他們的實際大小可能會有一點點的落差，因為items都有border，border的長度也是會被算在裡面的。）\nFlex-shrink 剛剛的Flex-grow是處理當Container有剩餘空間時，將items「伸展」來符合Container的長度；現在Flex-shrink則是處理當Container不夠items塞時，將items「縮小」來符合Container的長度。\n 在第一個範例裡Container的大小是600x350px，每個items的長度皆為300px，照理來講items的長度比Container還要長，那為什麼它們沒有爆開呢？答案是在預設裡其實就已經加上了Flex-shrink:1了～因此它們都會被包在Container裡面。我們可以來算算實際上items到底多長，3個items總長度為3*300=900，扣掉Container的600，因此差為300。而各自的Flex-shrink皆為1，故300/3=100，每個items的長度都要減去100，所以長度為200。第二範例就只是把Flex-shrink設為0，items總長大於Container，那麼就會爆開了。\n再來看看第三個範例，長寬依舊，但是Flex-shrink分別是2、3、1，故300/(2+3+1)=50。box1占了2份，300-(2＊50)=200；box2占了3份，300-(3＊50)=150；box3占了1份，300-(1＊50)=250。這樣各位有清楚了嗎～\nAlign-self   align-self  終終終於來到最後一個屬性了啊！！！！（撒花～\n這個屬性可以調整「副軸」的對齊屬性，再重申一次，是「副軸」喔不是主軸。它與Align-items、Align-content一樣可以控制副軸的排列方式，它卻能更進一步個別調整單一item的排列方式，以下是它的語法：\n\u0026lt;!-- css --\u0026gt; align-self: auto; /*預設，與Container的align-items一樣*/ align-self: flex-start; /*預設，靠頭對齊*/ align-self: flex-end; /*靠尾對齊*/ align-self: center; /*置中對齊*/ align-self: baseline; /*按照文本基線對齊*/ align-self: stretch; /*items延展至Container的頭尾*/   ＊特別注意！Align-self給定的值是會壓過Align-items、Align-content的喔\n結語 其實Flex並沒有想象中的那麼難，我當初在學習時也是看到一大堆屬性就頭昏腦花了，但只要先了解Container與items各自是負責做什麼的，以及主軸和副軸之間的關係，其他的即便忘了，網路上找一下就知道該怎麼使用了。前端的路途是很遙遠的，我們共勉之～\n 參考資料：\n圖解：CSS Flex 屬性一點也不難\nCSS | 所以我說那個版能不能好切一點？ - Flex 基本用法\n[css] 搞懂 flex-grow, flex-shirk 及 flex-basis 三種屬性\nCSS Flexbox\n圖片來源：\nA Complete Guide to Flexbox\n",
    "ref": "/blog/20200925_flexbox/"
  },{
    "title": "Fasure",
    "date": "",
    "description": "虛擬電商實作",
    "body": "這是我第一個電商網站，主要使用Bootstrap來切版。\n這網站算是我自學Bootstrap後所做出來的成果，當時我還不太懂Bootstrap是什麼，對於框架的概念不甚了解，於是我就上網自學。後來找到一本書專門介紹Bootstrap如何使用，於是我就跟著他的步驟，一點一點慢慢學習。\n 書名：讓響應式(RWD)網頁設計變簡單：Bootstrap開發速成\n作者：呂國泰\n 回到專案，當初在建置網頁時都是用Bootstrap，就連顏色配置這些也都是用Bootstrap內建顏色，因此版型看起來非常中規中矩，不過對於初學者來說這應該算及格了吧？\n但也多虧這個專案讓我能夠更加深入了解Bootstrap的用法，如grid system、card、collapsed等，這些東西需要經過反覆實作才能夠熟悉，不然很快就會忘記了。此外我也有用一些套件來讓版面看起來不這麼單調，如fontawesome的icon、AOS.js的下滑動畫等，這讓我之後懂得使用套件，提升網頁的多變性。\n  fasure  附上網站連結\n",
    "ref": "/portfolio/fasure/"
  },{
    "title": "[教學]圖片自適應外框大小",
    "date": "",
    "description": "台灣公益資訊中心改版實作心得",
    "body": "前言 暑假一眨眼就過去了，回顧過去這兩個月來我也學到不少東西。七月主要改版台灣公益資訊中心的頁面，將網站改成RWD頁面並且新增一些功能。由於專案還在開發階段，因此無法公開頁面內容，請以舊版的台灣公益資訊中心做為參考。\n接下來的分享主要以我在開發時遇到的困難、學習到的新東西為主。那我們就開始吧！\n圖片自適應外框大小 標題取為「圖片自適應外框大小」我想一定有很多人看不懂這到底是什麼意思。簡單來說，會使用本平台的人數百百種，當他們在上架內容時若剛好有圖片，就會有以下情況：\n 點擊上傳圖片 \u0026gt; 隨便丟一張覺得拍得不錯的照片 \u0026gt; 送出\n 剛剛的順序看似再正常不過了，不過使用者有想過隨邊丟一張圖片這確定沒問題嗎？？\n撇除照片檔案太大會影響載入速度外，另一個問題就是「照片的寬高比例」。現代人拍照通常都用手機，但是各家手機尺寸都不盡相同，若將未經裁切的照片丟上網頁，那一定會跑版\u0026hellip;\n解法一：max-width: 100%, max-height: 100% 為了解決這個問題，我原本的想法是在圖片的外層包一層div，並且控制外層大小及照片的排列方式。若照片比例與外框比例不符，它就會等比例縮在外框裡。\n\u0026lt;!-- html --\u0026gt; \u0026lt;div class=\u0026#34;pic\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://images.unsplash.com/photo-1600068643981-3c4496a2be55?ixlib=rb-1.2.1\u0026amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9\u0026amp;amp;auto=format\u0026amp;amp;fit=crop\u0026amp;amp;w=2467\u0026amp;amp;q=80\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pic\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://images.unsplash.com/photo-1599930499224-1b9a45439a12?ixlib=rb-1.2.1\u0026amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9\u0026amp;amp;auto=format\u0026amp;amp;fit=crop\u0026amp;amp;w=1164\u0026amp;amp;q=80\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; ＊圖片的src=\u0026quot;...\u0026quot;是在圖片地址，你可以換張圖片試試\n/* css */ html, body { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-wrap: wrap; background-color: #3d3d3d; } .pic { width: 500px; height: 350px; margin: 50px; display: flex; justify-content: center; align-items: center; border: 2px solid; } .pic img { max-width: 100%; max-height: 100%; } ＊html、body是為了排版用\n＊主要看.pic跟.pic img那邊，外層先固定好大小，並使用flex排版，讓裡面的內容能夠水平置中及垂直置中；內層的圖片分別在最大寬度、最大高度指定為100%，意思為寬高最大就是100%，若圖片的寬度大於高度，則寬度就是100%，而高度就依照比例去計算，反之亦然\n 解法二：object-fit 後來發現另一個更厲害的css內建語法，他叫做object-fit，若要以我剛剛的範例來說，它的語法就是object-fit: contain。\n\u0026lt;!-- html --\u0026gt; \u0026lt;div class=\u0026#34;pic\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://images.unsplash.com/photo-1600068643981-3c4496a2be55?ixlib=rb-1.2.1\u0026amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9\u0026amp;amp;auto=format\u0026amp;amp;fit=crop\u0026amp;amp;w=2467\u0026amp;amp;q=80\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pic\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://images.unsplash.com/photo-1599930499224-1b9a45439a12?ixlib=rb-1.2.1\u0026amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9\u0026amp;amp;auto=format\u0026amp;amp;fit=crop\u0026amp;amp;w=1164\u0026amp;amp;q=80\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; /* css */ html, body { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-wrap: wrap; background-color: #3d3d3d; } .pic { width: 500px; height: 350px; margin: 50px; border: 2px solid; } .pic img { object-fit: contain; width: 500px; height: 350px; } ＊使用object-fit就只要在圖片上加上語法，並且列出想要的寬高就可以了\n 眼尖的人可能會發現，它的語法大致跟background-size一樣，所以它同樣有好幾種顯示方式：\n fill：為預設值，強制讓圖片變形成外框的寬高。（很醜誒哈哈哈哈 contain：按照圖片等比例縮放塞入外框內。 cover：填滿外框，超出外框的部分會被裁切掉。 none：不做任何調整。（請問我要用你幹嘛？？ scale-down：取決於圖片與外框的大小。若外框小於圖片就用contain；若外框大於圖片就用none。  另外他還有個好朋友叫做object-position，可以理解為圖片在外框中的擺放位置，預設是在正中間。他們兩個可以互相搭配使用，說不定能擦出什麼火花（？？\n  object-fit、object-position瀏覽器支援程度  BTW，剛剛講的object-fit、object-position並不支援IE喔，不過現在應該很少人在用IE了吧！\n結語 其實還有很多種方式可以達成圖片自適應外框大小，若你有新的作法與想法，歡迎在下方留言喔！\n",
    "ref": "/blog/20200914/"
  },{
    "title": "About",
    "date": "",
    "description": "自我介紹內容～",
    "body": "你好，我是米米，是個剛畢業就已經成為社畜的前端工程師==\n因緣際會下接觸到前端工程，因此開始了我的前端人生。在這裡我會分享我的所見所聞，主要以工作上學習到的心得為主。還有偶爾發發廢文（？\n",
    "ref": "/about/"
  }]
